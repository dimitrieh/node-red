/**
 * Copyright JS Foundation and other contributors, http://js.foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

RED.comms = (function() {

    var errornotification = null;
    var clearErrorTimer = null;
    var connectCountdownTimer = null;
    var connectCountdown = 10;
    var subscriptions = {};
    var binarySubscriptions = {}; // For binary message handlers (Automerge sync)
    var ws;
    var pendingAuth = false;
    var reconnectAttempts = 0;
    var active = false;

    RED.events.on('login', function(username) {
        // User has logged in
        // Need to upgrade the connection to be authenticated
        if (ws && ws.readyState == 1) {
            const auth_tokens = RED.settings.get("auth-tokens");
            ws.send(JSON.stringify({auth:auth_tokens.access_token}))
        }
    })

    function connectWS() {
        active = true;
        var wspath;

        if (RED.settings.apiRootUrl) {
            var m = /^(https?):\/\/(.*)$/.exec(RED.settings.apiRootUrl);
            if (m) {
                console.log(m);
                wspath = "ws"+(m[1]==="https"?"s":"")+"://"+m[2]+"comms";
            }
        } else {
            var path = location.hostname;
            var port = location.port;
            if (port.length !== 0) {
                path = path+":"+port;
            }
            path = path+document.location.pathname;
            path = path+(path.slice(-1) == "/"?"":"/")+"comms";
            wspath = "ws"+(document.location.protocol=="https:"?"s":"")+"://"+path;
        }

        var auth_tokens = RED.settings.get("auth-tokens");
        pendingAuth = (auth_tokens!=null);

        function completeConnection() {
            for (var t in subscriptions) {
                if (subscriptions.hasOwnProperty(t)) {
                    ws.send(JSON.stringify({subscribe:t}));
                }
            }
            emit('connect')
        }

        ws = new WebSocket(wspath);
        ws.binaryType = 'arraybuffer'; // Enable binary message support for Automerge
        ws.onopen = function() {
            reconnectAttempts = 0;
            if (errornotification) {
                clearErrorTimer = setTimeout(function() {
                    errornotification.close();
                    errornotification = null;
                },1000);
            }
            if (pendingAuth) {
                ws.send(JSON.stringify({auth:auth_tokens.access_token}));
            } else {
                completeConnection();
            }
        }
        ws.onmessage = function(event) {
            // Handle binary messages (Automerge sync)
            if (event.data instanceof ArrayBuffer) {
                handleBinaryMessage(new Uint8Array(event.data));
                return;
            }

            var message = JSON.parse(event.data);
            if (message.auth) {
                if (pendingAuth) {
                    if (message.auth === "ok") {
                        pendingAuth = false;
                        completeConnection();
                    } else if (message.auth === "fail") {
                        // anything else is an error...
                        active = false;
                        RED.user.login({updateMenu:true},function() {
                            connectWS();
                        })
                    }
                } else if (message.auth === "fail") {
                    // Our current session has expired
                    active = false;
                    RED.user.login({updateMenu:true},function() {
                        connectWS();
                    })
                }
            } else {
                // Otherwise, 'message' is an array of actual comms messages
                for (var m = 0; m < message.length; m++) {
                    var msg = message[m];
                    if (msg.topic) {
                        for (var t in subscriptions) {
                            if (subscriptions.hasOwnProperty(t)) {
                                var re = new RegExp("^"+t.replace(/([\[\]\?\(\)\\\\$\^\*\.|])/g,"\\$1").replace(/\+/g,"[^/]+").replace(/\/#$/,"(\/.*)?")+"$");
                                if (re.test(msg.topic)) {
                                    var subscribers = subscriptions[t];
                                    if (subscribers) {
                                        for (var i=0;i<subscribers.length;i++) {
                                            try {
                                                subscribers[i](msg.topic,msg.data);
                                            } catch (error) {
                                                // need to decide what to do with this uncaught error
                                                console.warn('Uncaught error from RED.comms.subscribe: ' + error.toString())
                                                console.warn(error)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        ws.onclose = function() {
            if (!active) {
                return;
            }
            if (clearErrorTimer) {
                clearTimeout(clearErrorTimer);
                clearErrorTimer = null;
            }
            reconnectAttempts++;
            if (reconnectAttempts < 10) {
                setTimeout(connectWS,1000);
                if (reconnectAttempts > 5 && errornotification == null) {
                    errornotification = RED.notify(RED._("notification.errors.lostConnection"),"error",true);
                }
            } else if (reconnectAttempts < 20) {
                setTimeout(connectWS,2000);
            } else {
                connectCountdown = 60;
                connectCountdownTimer = setInterval(function() {
                    connectCountdown--;
                    if (connectCountdown === 0) {
                        errornotification.update(RED._("notification.errors.lostConnection"));
                        clearInterval(connectCountdownTimer);
                        connectWS();
                    } else {
                        var msg = RED._("notification.errors.lostConnectionReconnect",{time: connectCountdown})+' <a href="#">'+ RED._("notification.errors.lostConnectionTry")+'</a>';
                        errornotification.update(msg,{silent:true});
                        $(errornotification).find("a").on("click", function(e) {
                            e.preventDefault();
                            errornotification.update(RED._("notification.errors.lostConnection"),{silent:true});
                            clearInterval(connectCountdownTimer);
                            connectWS();
                        })
                    }
                },1000);
            }

        }
    }

    function subscribe(topic,callback) {
        if (subscriptions[topic] == null) {
            subscriptions[topic] = [];
        }
        subscriptions[topic].push(callback);
        if (ws && ws.readyState == 1) {
            ws.send(JSON.stringify({subscribe:topic}));
        }
    }

    function unsubscribe(topic,callback) {
        if (subscriptions[topic]) {
            for (var i=0;i<subscriptions[topic].length;i++) {
                if (subscriptions[topic][i] === callback) {
                    subscriptions[topic].splice(i,1);
                    break;
                }
            }
            if (subscriptions[topic].length === 0) {
                delete subscriptions[topic];
            }
        }
    }

    function send(topic, msg) {
        if (ws && ws.readyState == 1) {
            ws.send(JSON.stringify({
                topic,
                data: msg
            }))
        }
    }

    /**
     * Send a binary message over WebSocket
     * Format: [1 byte type][4 bytes topic length][topic bytes][payload bytes]
     * @param {string} topic - Message topic
     * @param {Uint8Array} data - Binary data
     */
    function sendBinary(topic, data) {
        if (ws && ws.readyState == 1) {
            const topicBytes = new TextEncoder().encode(topic);
            const message = new Uint8Array(1 + 4 + topicBytes.length + data.length);

            // Type byte (1 = binary message)
            message[0] = 1;

            // Topic length (4 bytes, big-endian)
            const topicLen = topicBytes.length;
            message[1] = (topicLen >> 24) & 0xff;
            message[2] = (topicLen >> 16) & 0xff;
            message[3] = (topicLen >> 8) & 0xff;
            message[4] = topicLen & 0xff;

            // Topic
            message.set(topicBytes, 5);

            // Payload
            message.set(data, 5 + topicBytes.length);

            ws.send(message.buffer);
        }
    }

    /**
     * Handle incoming binary message
     * @param {Uint8Array} data - Binary message data
     */
    function handleBinaryMessage(data) {
        if (data.length < 5) return;

        const type = data[0];
        if (type !== 1) return; // Only handle type 1 (binary message)

        // Extract topic length
        const topicLen = (data[1] << 24) | (data[2] << 16) | (data[3] << 8) | data[4];
        if (data.length < 5 + topicLen) return;

        // Extract topic
        const topicBytes = data.slice(5, 5 + topicLen);
        const topic = new TextDecoder().decode(topicBytes);

        // Extract payload
        const payload = data.slice(5 + topicLen);

        // Dispatch to binary subscribers
        for (var t in binarySubscriptions) {
            if (binarySubscriptions.hasOwnProperty(t)) {
                var re = new RegExp("^"+t.replace(/([\[\]\?\(\)\\\\$\^\*\.|])/g,"\\$1").replace(/\+/g,"[^/]+").replace(/\/#$/,"(\/.*)?")+"$");
                if (re.test(topic)) {
                    var subscribers = binarySubscriptions[t];
                    if (subscribers) {
                        for (var i=0;i<subscribers.length;i++) {
                            try {
                                subscribers[i](topic, payload);
                            } catch (error) {
                                console.warn('Uncaught error from RED.comms.subscribeBinary: ' + error.toString())
                                console.warn(error)
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     * Subscribe to binary messages on a topic
     * @param {string} topic - Topic pattern
     * @param {Function} callback - Callback(topic, Uint8Array)
     */
    function subscribeBinary(topic, callback) {
        if (binarySubscriptions[topic] == null) {
            binarySubscriptions[topic] = [];
        }
        binarySubscriptions[topic].push(callback);
    }

    /**
     * Unsubscribe from binary messages
     * @param {string} topic - Topic pattern
     * @param {Function} callback - Callback to remove
     */
    function unsubscribeBinary(topic, callback) {
        if (binarySubscriptions[topic]) {
            for (var i=0;i<binarySubscriptions[topic].length;i++) {
                if (binarySubscriptions[topic][i] === callback) {
                    binarySubscriptions[topic].splice(i,1);
                    break;
                }
            }
            if (binarySubscriptions[topic].length === 0) {
                delete binarySubscriptions[topic];
            }
        }
    }

    const eventHandlers = {};
    function on(evt,func) {
        eventHandlers[evt] = eventHandlers[evt]||[];
        eventHandlers[evt].push(func);
    }
    function off(evt,func) {
        const handler = eventHandlers[evt];
        if (handler) {
            for (let i=0;i<handler.length;i++) {
                if (handler[i] === func) {
                    handler.splice(i,1);
                    return;
                }
            }
        }
    }
    function emit() {
        const evt = arguments[0]
        const args = Array.prototype.slice.call(arguments,1);
        if (eventHandlers[evt]) {
            let cpyHandlers = [...eventHandlers[evt]];
            for (let i=0;i<cpyHandlers.length;i++) {
                try {
                    cpyHandlers[i].apply(null, args);
                } catch(err) {
                    console.warn("RED.comms.emit error: ["+evt+"] "+(err.toString()));
                    console.warn(err);
                }
            }
        }
    }

    return {
        connect: connectWS,
        subscribe: subscribe,
        unsubscribe:unsubscribe,
        subscribeBinary: subscribeBinary,
        unsubscribeBinary: unsubscribeBinary,
        on,
        off,
        send,
        sendBinary: sendBinary
    }
})();
