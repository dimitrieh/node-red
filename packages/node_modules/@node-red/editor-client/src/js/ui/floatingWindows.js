/**
 * Floating Windows System for Node-RED
 * Provides draggable, resizable floating windows for palette and sidebar
 */

RED.floatingWindows = (function() {
    
    const windows = new Map();
    let activeWindow = null;
    let dragState = null;
    let resizeState = null;
    let windowCounter = 0;
    
    // Configuration defaults
    const defaults = {
        minWidth: 250,
        minHeight: 150,
        defaultWidth: 300,
        defaultHeight: 400,
        snapThreshold: 10,
        zIndexBase: 100
    };
    
    /**
     * Create a new floating window
     * @param {Object} options - Window configuration
     * @returns {Object} Window instance
     */
    function createWindow(options) {
        const windowId = 'floating-window-' + (++windowCounter);
        const config = Object.assign({}, defaults, options);
        
        // Create window DOM structure
        const windowEl = $(`
            <div id="${windowId}" class="red-ui-floating-window" style="display: none;">
                <div class="red-ui-floating-window-header">
                    <div class="red-ui-floating-window-title">${config.title || 'Window'}</div>
                    <div class="red-ui-floating-window-controls">
                        <button class="red-ui-floating-window-control red-ui-floating-window-minimize" title="Minimize"></button>
                        <button class="red-ui-floating-window-control red-ui-floating-window-maximize" title="Maximize"></button>
                        <button class="red-ui-floating-window-control red-ui-floating-window-close" title="Close"></button>
                    </div>
                </div>
                <div class="red-ui-floating-window-content"></div>
                <div class="red-ui-floating-window-resize-handle red-ui-resize-n"></div>
                <div class="red-ui-floating-window-resize-handle red-ui-resize-s"></div>
                <div class="red-ui-floating-window-resize-handle red-ui-resize-e"></div>
                <div class="red-ui-floating-window-resize-handle red-ui-resize-w"></div>
                <div class="red-ui-floating-window-resize-handle red-ui-resize-ne"></div>
                <div class="red-ui-floating-window-resize-handle red-ui-resize-nw"></div>
                <div class="red-ui-floating-window-resize-handle red-ui-resize-se"></div>
                <div class="red-ui-floating-window-resize-handle red-ui-resize-sw"></div>
            </div>
        `);
        
        // Append to main container
        $('#red-ui-main-container').append(windowEl);
        
        const window = {
            id: windowId,
            element: windowEl,
            config: config,
            isMinimized: false,
            isMaximized: false,
            position: { x: 0, y: 0 },
            size: { width: config.defaultWidth, height: config.defaultHeight },
            originalState: null // For restore from maximize
        };
        
        // Set initial position
        if (config.x !== undefined && config.y !== undefined) {
            window.position.x = config.x;
            window.position.y = config.y;
        } else {
            // Auto-position based on existing windows
            const offset = windows.size * 20;
            window.position.x = Math.max(20, 20 + offset);
            window.position.y = Math.max(60, 60 + offset); // Account for header
        }
        
        // Set initial size
        if (config.width) window.size.width = config.width;
        if (config.height) window.size.height = config.height;
        
        // Apply initial positioning and sizing
        updateWindowTransform(window);
        
        // Bind event handlers
        bindWindowEvents(window);
        
        // Store window reference
        windows.set(windowId, window);
        
        return window;
    }
    
    /**
     * Update window position and size on DOM
     */
    function updateWindowTransform(window) {
        const { x, y } = window.position;
        const { width, height } = window.size;
        
        window.element.css({
            left: x + 'px',
            top: y + 'px',
            width: width + 'px',
            height: height + 'px'
        });
    }
    
    /**
     * Bind all event handlers for a window
     */
    function bindWindowEvents(window) {
        const windowEl = window.element;
        const header = windowEl.find('.red-ui-floating-window-header');
        
        // Window focus
        windowEl.on('mousedown', function(e) {
            setActiveWindow(window);
        });
        
        // Header drag
        header.on('mousedown', function(e) {
            if ($(e.target).hasClass('red-ui-floating-window-control')) {
                return; // Don't drag when clicking controls
            }
            
            startDrag(window, e);
        });
        
        // Control buttons
        windowEl.find('.red-ui-floating-window-minimize').on('click', function() {
            toggleMinimize(window);
        });
        
        windowEl.find('.red-ui-floating-window-maximize').on('click', function() {
            toggleMaximize(window);
        });
        
        windowEl.find('.red-ui-floating-window-close').on('click', function() {
            hideWindow(window);
        });
        
        // Resize handles
        windowEl.find('.red-ui-floating-window-resize-handle').on('mousedown', function(e) {
            const direction = this.className.split(' ').find(cls => cls.startsWith('red-ui-resize-'));
            startResize(window, e, direction.replace('red-ui-resize-', ''));
        });
        
        // Touch support for mobile
        if ('ontouchstart' in window) {
            bindTouchEvents(window);
        }
    }
    
    /**
     * Bind touch events for mobile support
     */
    function bindTouchEvents(window) {
        const header = window.element.find('.red-ui-floating-window-header');
        
        header.on('touchstart', function(e) {
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    bubbles: true
                });
                e.preventDefault();
                this.dispatchEvent(mouseEvent);
            }
        });
    }
    
    /**
     * Start dragging a window
     */
    function startDrag(window, e) {
        if (window.isMaximized) return;
        
        dragState = {
            window: window,
            startX: e.clientX - window.position.x,
            startY: e.clientY - window.position.y,
            isDragging: false
        };
        
        $(document).on('mousemove.floating-window-drag', handleDrag);
        $(document).on('mouseup.floating-window-drag', endDrag);
        
        e.preventDefault();
    }
    
    /**
     * Handle drag movement
     */
    function handleDrag(e) {
        if (!dragState) return;
        
        const window = dragState.window;
        const newX = e.clientX - dragState.startX;
        const newY = e.clientY - dragState.startY;
        
        // Mark as dragging for visual feedback
        if (!dragState.isDragging) {
            dragState.isDragging = true;
            window.element.addClass('red-ui-floating-window-dragging');
        }
        
        // Constrain to viewport
        const containerBounds = getContainerBounds();
        window.position.x = Math.max(0, Math.min(newX, containerBounds.width - window.size.width));
        window.position.y = Math.max(0, Math.min(newY, containerBounds.height - window.size.height));
        
        updateWindowTransform(window);
        
        // Check for snap-to-edge
        checkSnapToEdge(window, containerBounds);
        
        e.preventDefault();
    }
    
    /**
     * End drag operation
     */
    function endDrag() {
        if (dragState && dragState.isDragging) {
            dragState.window.element.removeClass('red-ui-floating-window-dragging');
        }
        
        $(document).off('.floating-window-drag');
        dragState = null;
    }
    
    /**
     * Start resizing a window
     */
    function startResize(window, e, direction) {
        if (window.isMaximized || window.isMinimized) return;
        
        resizeState = {
            window: window,
            direction: direction,
            startX: e.clientX,
            startY: e.clientY,
            startPosition: { ...window.position },
            startSize: { ...window.size }
        };
        
        $(document).on('mousemove.floating-window-resize', handleResize);
        $(document).on('mouseup.floating-window-resize', endResize);
        
        window.element.addClass('red-ui-floating-window-resizing');
        
        e.preventDefault();
        e.stopPropagation();
    }
    
    /**
     * Handle resize movement
     */
    function handleResize(e) {
        if (!resizeState) return;
        
        const window = resizeState.window;
        const deltaX = e.clientX - resizeState.startX;
        const deltaY = e.clientY - resizeState.startY;
        const direction = resizeState.direction;
        
        let newX = resizeState.startPosition.x;
        let newY = resizeState.startPosition.y;
        let newWidth = resizeState.startSize.width;
        let newHeight = resizeState.startSize.height;
        
        // Calculate new dimensions based on resize direction
        if (direction.includes('e')) {
            newWidth += deltaX;
        }
        if (direction.includes('w')) {
            newWidth -= deltaX;
            newX += deltaX;
        }
        if (direction.includes('s')) {
            newHeight += deltaY;
        }
        if (direction.includes('n')) {
            newHeight -= deltaY;
            newY += deltaY;
        }
        
        // Enforce minimum size
        newWidth = Math.max(window.config.minWidth, newWidth);
        newHeight = Math.max(window.config.minHeight, newHeight);
        
        // Adjust position if size was constrained
        if (direction.includes('w') && newWidth === window.config.minWidth) {
            newX = resizeState.startPosition.x + resizeState.startSize.width - newWidth;
        }
        if (direction.includes('n') && newHeight === window.config.minHeight) {
            newY = resizeState.startPosition.y + resizeState.startSize.height - newHeight;
        }
        
        // Update window
        window.position.x = newX;
        window.position.y = newY;
        window.size.width = newWidth;
        window.size.height = newHeight;
        
        updateWindowTransform(window);
        
        e.preventDefault();
    }
    
    /**
     * End resize operation
     */
    function endResize() {
        if (resizeState) {
            resizeState.window.element.removeClass('red-ui-floating-window-resizing');
        }
        
        $(document).off('.floating-window-resize');
        resizeState = null;
    }
    
    /**
     * Check if window should snap to edges
     */
    function checkSnapToEdge(window, containerBounds) {
        const threshold = window.config.snapThreshold || defaults.snapThreshold;
        const pos = window.position;
        
        // Remove existing dock classes
        window.element.removeClass('red-ui-floating-window-docked red-ui-docked-left red-ui-docked-right red-ui-docked-top red-ui-docked-bottom');
        
        // Check for edge snapping
        if (pos.x <= threshold) {
            pos.x = 0;
            window.element.addClass('red-ui-floating-window-docked red-ui-docked-left');
        }
        
        if (pos.x + window.size.width >= containerBounds.width - threshold) {
            pos.x = containerBounds.width - window.size.width;
            window.element.addClass('red-ui-floating-window-docked red-ui-docked-right');
        }
        
        if (pos.y <= threshold) {
            pos.y = 0;
            window.element.addClass('red-ui-floating-window-docked red-ui-docked-top');
        }
    }
    
    /**
     * Get container bounds for window positioning
     */
    function getContainerBounds() {
        const container = $('#red-ui-main-container');
        return {
            width: container.width(),
            height: container.height()
        };
    }
    
    /**
     * Set the active (focused) window
     */
    function setActiveWindow(window) {
        if (activeWindow === window) return;
        
        // Remove focus from previous active window
        if (activeWindow) {
            activeWindow.element.removeClass('red-ui-floating-window-focused');
            activeWindow.element.css('z-index', defaults.zIndexBase);
        }
        
        // Set new active window
        activeWindow = window;
        window.element.addClass('red-ui-floating-window-focused');
        window.element.css('z-index', defaults.zIndexBase + 100);
    }
    
    /**
     * Toggle window minimize state
     */
    function toggleMinimize(window) {
        if (window.isMinimized) {
            // Restore
            window.isMinimized = false;
            window.element.removeClass('red-ui-floating-window-minimized');
            window.element.css('height', window.size.height + 'px');
        } else {
            // Minimize
            window.isMinimized = true;
            window.element.addClass('red-ui-floating-window-minimized');
        }
    }
    
    /**
     * Toggle window maximize state
     */
    function toggleMaximize(window) {
        if (window.isMaximized) {
            // Restore
            if (window.originalState) {
                window.position = { ...window.originalState.position };
                window.size = { ...window.originalState.size };
                window.originalState = null;
            }
            window.isMaximized = false;
            window.element.removeClass('red-ui-floating-window-docked');
        } else {
            // Maximize
            window.originalState = {
                position: { ...window.position },
                size: { ...window.size }
            };
            
            const containerBounds = getContainerBounds();
            window.position = { x: 0, y: 0 };
            window.size = { 
                width: containerBounds.width, 
                height: containerBounds.height 
            };
            window.isMaximized = true;
        }
        
        updateWindowTransform(window);
    }
    
    /**
     * Show a window
     */
    function showWindow(windowId) {
        const window = windows.get(windowId);
        if (window) {
            window.element.show();
            setActiveWindow(window);
        }
    }
    
    /**
     * Hide a window
     */
    function hideWindow(window) {
        if (typeof window === 'string') {
            window = windows.get(window);
        }
        
        if (window) {
            window.element.hide();
            if (activeWindow === window) {
                activeWindow = null;
            }
        }
    }
    
    /**
     * Get a window instance
     */
    function getWindow(windowId) {
        return windows.get(windowId);
    }
    
    /**
     * Set window content
     */
    function setWindowContent(windowId, content) {
        const window = windows.get(windowId);
        if (window) {
            window.element.find('.red-ui-floating-window-content').empty().append(content);
        }
    }
    
    /**
     * Handle window resize when container changes
     */
    function handleContainerResize() {
        const containerBounds = getContainerBounds();
        
        windows.forEach(window => {
            // Ensure windows stay within bounds
            if (window.position.x + window.size.width > containerBounds.width) {
                window.position.x = Math.max(0, containerBounds.width - window.size.width);
            }
            if (window.position.y + window.size.height > containerBounds.height) {
                window.position.y = Math.max(0, containerBounds.height - window.size.height);
            }
            
            updateWindowTransform(window);
        });
    }
    
    // Initialize container resize handler
    $(window).on('resize', handleContainerResize);
    
    // Public API
    return {
        createWindow: createWindow,
        showWindow: showWindow,
        hideWindow: hideWindow,
        getWindow: getWindow,
        setWindowContent: setWindowContent,
        handleContainerResize: handleContainerResize
    };
    
})();