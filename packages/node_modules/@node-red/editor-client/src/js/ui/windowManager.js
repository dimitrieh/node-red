/**
 * Copyright JS Foundation and other contributors, http://js.foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

RED.windowManager = (function() {

    var registeredWindows = {};
    var windowOrder = [];
    
    function init() {
        // Add keyboard shortcuts for window management
        RED.actions.add("core:toggle-palette-window", function() {
            toggleWindow('palette');
        });
        
        RED.actions.add("core:toggle-sidebar-window", function() {
            toggleWindow('sidebar');
        });
        
        RED.actions.add("core:cycle-windows", function() {
            cycleWindows();
        });
        
        RED.actions.add("core:reset-window-positions", function() {
            resetWindowPositions();
        });
        
        // Handle window resize to adjust window constraints
        $(window).on('resize', function() {
            adjustWindowsToViewport();
        });
    }
    
    function registerWindow(id, windowInstance, options) {
        registeredWindows[id] = {
            instance: windowInstance,
            options: options || {}
        };
        
        if (!windowOrder.includes(id)) {
            windowOrder.push(id);
        }
        
        // Set up keyboard shortcut if specified
        if (options.shortcut) {
            RED.actions.add(options.shortcut.action, function() {
                toggleWindow(id);
            });
        }
    }
    
    function unregisterWindow(id) {
        if (registeredWindows[id]) {
            registeredWindows[id].instance.destroy();
            delete registeredWindows[id];
            
            var index = windowOrder.indexOf(id);
            if (index > -1) {
                windowOrder.splice(index, 1);
            }
        }
    }
    
    function toggleWindow(id) {
        var window = registeredWindows[id];
        if (window) {
            var windowData = RED.floatingWindow.get(id);
            if (windowData && windowData.minimized) {
                window.instance.restore();
            } else if (windowData && windowData.element.is(':visible')) {
                window.instance.minimize();
            } else {
                window.instance.show();
            }
        }
    }
    
    function showWindow(id) {
        var window = registeredWindows[id];
        if (window) {
            window.instance.show();
        }
    }
    
    function hideWindow(id) {
        var window = registeredWindows[id];
        if (window) {
            window.instance.hide();
        }
    }
    
    function minimizeWindow(id) {
        var window = registeredWindows[id];
        if (window) {
            window.instance.minimize();
        }
    }
    
    function restoreWindow(id) {
        var window = registeredWindows[id];
        if (window) {
            window.instance.restore();
        }
    }
    
    function cycleWindows() {
        var visibleWindows = windowOrder.filter(function(id) {
            var windowData = RED.floatingWindow.get(id);
            return windowData && windowData.element.is(':visible') && !windowData.minimized;
        });
        
        if (visibleWindows.length <= 1) return;
        
        // Find currently focused window (highest z-index)
        var currentWindow = null;
        var highestZ = -1;
        
        visibleWindows.forEach(function(id) {
            var windowData = RED.floatingWindow.get(id);
            var zIndex = parseInt(windowData.element.css('zIndex'));
            if (zIndex > highestZ) {
                highestZ = zIndex;
                currentWindow = id;
            }
        });
        
        // Focus next window
        var currentIndex = visibleWindows.indexOf(currentWindow);
        var nextIndex = (currentIndex + 1) % visibleWindows.length;
        var nextWindow = visibleWindows[nextIndex];
        
        RED.floatingWindow.bringToFront(nextWindow);
    }
    
    function resetWindowPositions() {
        var offset = 50;
        var spacing = 30;
        
        windowOrder.forEach(function(id, index) {
            var window = registeredWindows[id];
            if (window) {
                // Clear saved state
                localStorage.removeItem('red-ui-floating-window-' + id);
                
                // Set default positions with cascade
                var x = offset + (index * spacing);
                var y = offset + (index * spacing);
                
                var windowData = RED.floatingWindow.get(id);
                if (windowData) {
                    windowData.element.css({
                        left: x + 'px',
                        top: y + 'px',
                        width: window.options.defaultWidth || '300px',
                        height: window.options.defaultHeight || '400px'
                    });
                }
            }
        });
    }
    
    function adjustWindowsToViewport() {
        var viewportWidth = window.innerWidth;
        var viewportHeight = window.innerHeight;
        
        Object.keys(registeredWindows).forEach(function(id) {
            var windowData = RED.floatingWindow.get(id);
            if (windowData) {
                var element = windowData.element;
                var currentLeft = parseInt(element.css('left'));
                var currentTop = parseInt(element.css('top'));
                var currentWidth = parseInt(element.css('width'));
                var currentHeight = parseInt(element.css('height'));
                
                // Ensure window is not completely off-screen
                var newLeft = Math.max(0, Math.min(currentLeft, viewportWidth - 100));
                var newTop = Math.max(0, Math.min(currentTop, viewportHeight - 32));
                
                // Adjust size if needed
                var maxWidth = Math.max(200, viewportWidth - newLeft - 20);
                var maxHeight = Math.max(150, viewportHeight - newTop - 20);
                var newWidth = Math.min(currentWidth, maxWidth);
                var newHeight = Math.min(currentHeight, maxHeight);
                
                if (newLeft !== currentLeft || newTop !== currentTop || 
                    newWidth !== currentWidth || newHeight !== currentHeight) {
                    element.css({
                        left: newLeft + 'px',
                        top: newTop + 'px',
                        width: newWidth + 'px',
                        height: newHeight + 'px'
                    });
                    
                    // Trigger resize event
                    element.trigger('windowResize');
                }
            }
        });
    }
    
    function getAllWindows() {
        return Object.keys(registeredWindows).map(function(id) {
            return {
                id: id,
                instance: registeredWindows[id].instance,
                options: registeredWindows[id].options
            };
        });
    }
    
    function isWindowVisible(id) {
        var windowData = RED.floatingWindow.get(id);
        return windowData && windowData.element.is(':visible') && !windowData.minimized;
    }
    
    return {
        init: init,
        register: registerWindow,
        unregister: unregisterWindow,
        toggle: toggleWindow,
        show: showWindow,
        hide: hideWindow,
        minimize: minimizeWindow,
        restore: restoreWindow,
        cycle: cycleWindows,
        reset: resetWindowPositions,
        getAllWindows: getAllWindows,
        isVisible: isWindowVisible
    };

})();