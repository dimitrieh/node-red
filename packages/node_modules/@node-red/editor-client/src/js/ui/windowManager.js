/**
 * Copyright JS Foundation and other contributors, http://js.foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

RED.windowManager = (function() {

    var registeredWindows = {};
    var keyboardShortcuts = {};

    function init() {
        setupKeyboardShortcuts();
    }

    function setupKeyboardShortcuts() {
        // Toggle palette window (Ctrl+1)
        keyboardShortcuts['ctrl-1'] = function() {
            toggleWindow('palette');
        };

        // Toggle sidebar window (Ctrl+2) 
        keyboardShortcuts['ctrl-2'] = function() {
            toggleWindow('sidebar');
        };

        // Cycle through windows (Alt+Tab)
        keyboardShortcuts['alt-tab'] = function() {
            cycleWindows();
        };

        // Register keyboard shortcuts with RED.keyboard
        RED.keyboard.add("*", "ctrl-1", keyboardShortcuts['ctrl-1']);
        RED.keyboard.add("*", "ctrl-2", keyboardShortcuts['ctrl-2']);
        RED.keyboard.add("*", "alt-tab", keyboardShortcuts['alt-tab']);
    }

    function registerWindow(windowId, windowAPI, options) {
        registeredWindows[windowId] = {
            api: windowAPI,
            visible: options.visible !== false,
            toggleable: options.toggleable !== false,
            title: options.title || windowId
        };
        
        console.log('Registered floating window:', windowId);
    }

    function unregisterWindow(windowId) {
        if (registeredWindows[windowId]) {
            delete registeredWindows[windowId];
            console.log('Unregistered floating window:', windowId);
        }
    }

    function toggleWindow(windowId) {
        var window = registeredWindows[windowId];
        if (!window || !window.toggleable) {
            console.warn('Cannot toggle window:', windowId);
            return;
        }

        if (window.visible) {
            window.api.hide();
            window.visible = false;
        } else {
            window.api.show();
            window.api.focus();
            window.visible = true;
        }

        console.log('Toggled window ' + windowId + ':', window.visible ? 'shown' : 'hidden');
    }

    function showWindow(windowId) {
        var window = registeredWindows[windowId];
        if (window && !window.visible) {
            window.api.show();
            window.api.focus();
            window.visible = true;
            console.log('Showed window:', windowId);
        }
    }

    function hideWindow(windowId) {
        var window = registeredWindows[windowId];
        if (window && window.visible) {
            window.api.hide();
            window.visible = false;
            console.log('Hidden window:', windowId);
        }
    }

    function focusWindow(windowId) {
        var window = registeredWindows[windowId];
        if (window && window.visible) {
            window.api.focus();
        }
    }

    function cycleWindows() {
        var visibleWindows = [];
        var windowIds = Object.keys(registeredWindows);
        
        for (var i = 0; i < windowIds.length; i++) {
            var windowId = windowIds[i];
            var window = registeredWindows[windowId];
            if (window.visible) {
                visibleWindows.push(windowId);
            }
        }

        if (visibleWindows.length === 0) {
            return;
        }

        // Simple focus cycling - focus next visible window
        var currentFocused = getCurrentFocusedWindow();
        var currentIndex = visibleWindows.indexOf(currentFocused);
        var nextIndex = (currentIndex + 1) % visibleWindows.length;
        
        focusWindow(visibleWindows[nextIndex]);
    }

    function getCurrentFocusedWindow() {
        // Find window with highest z-index
        var maxZIndex = 0;
        var focusedWindow = null;
        
        Object.keys(registeredWindows).forEach(function(windowId) {
            var window = registeredWindows[windowId];
            if (window.visible && window.api.element) {
                var zIndex = parseInt(window.api.element.css('z-index')) || 0;
                if (zIndex > maxZIndex) {
                    maxZIndex = zIndex;
                    focusedWindow = windowId;
                }
            }
        });
        
        return focusedWindow;
    }

    function getVisibleWindows() {
        return Object.keys(registeredWindows).filter(function(windowId) {
            return registeredWindows[windowId].visible;
        });
    }

    function getAllWindows() {
        return Object.keys(registeredWindows);
    }

    function isWindowVisible(windowId) {
        var window = registeredWindows[windowId];
        return window ? window.visible : false;
    }

    function resetWindowPositions() {
        Object.keys(registeredWindows).forEach(function(windowId) {
            // Clear saved positions
            localStorage.removeItem('floating-window-' + windowId);
            
            // Reset to default positions
            var window = registeredWindows[windowId];
            if (window.api.element) {
                // Default positions
                var defaultPositions = {
                    'palette': { x: 50, y: 100 },
                    'sidebar': { x: 300, y: 100 }
                };
                
                var pos = defaultPositions[windowId] || { x: 100, y: 100 };
                window.api.element.css({
                    left: pos.x + 'px',
                    top: pos.y + 'px'
                });
            }
        });
        
        console.log('Reset all window positions to defaults');
    }

    function getWindowStates() {
        var states = {};
        Object.keys(registeredWindows).forEach(function(windowId) {
            var window = registeredWindows[windowId];
            states[windowId] = {
                visible: window.visible,
                position: window.api.getPosition ? window.api.getPosition() : null,
                size: window.api.getSize ? window.api.getSize() : null
            };
        });
        return states;
    }

    // Handle window resize events to reposition windows if needed
    function handleViewportResize() {
        Object.keys(registeredWindows).forEach(function(windowId) {
            var floatingWindow = RED.floatingWindow.getWindow(windowId);
            if (floatingWindow) {
                // Use the floating window's constraint function
                RED.floatingWindow.constrainToViewport && RED.floatingWindow.constrainToViewport(windowId);
            }
        });
    }

    // Setup viewport resize handling
    $(window).on('resize', function() {
        setTimeout(handleViewportResize, 100); // Debounce resize events
    });

    // Public API
    return {
        init: init,
        register: registerWindow,
        unregister: unregisterWindow,
        toggle: toggleWindow,
        show: showWindow,
        hide: hideWindow,
        focus: focusWindow,
        cycle: cycleWindows,
        isVisible: isWindowVisible,
        getVisible: getVisibleWindows,
        getAll: getAllWindows,
        getStates: getWindowStates,
        resetPositions: resetWindowPositions,
        handleResize: handleViewportResize
    };

})();