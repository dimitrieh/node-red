/**
 * Copyright JS Foundation and other contributors, http://js.foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

/**
 * Automerge Client for Node-RED Editor
 *
 * Manages the client-side Automerge document and synchronization
 * with the runtime server.
 *
 * @namespace RED.automerge
 */
RED.automerge = (function() {
    const SCHEMA_VERSION = "1.0";

    function stripUndefined(obj) {
        if (obj === null || typeof obj !== 'object') return obj;
        if (Array.isArray(obj)) return obj.map(stripUndefined);
        var result = {};
        for (var key in obj) {
            if (obj.hasOwnProperty(key) && obj[key] !== undefined && typeof obj[key] !== 'function') {
                result[key] = stripUndefined(obj[key]);
            }
        }
        return result;
    }

    let Automerge = null;
    let doc = null;
    let syncState = null;
    let enabled = false;
    let initialized = false;

    // Checkpoint management for undo/redo
    let checkpoints = [];
    let currentCheckpointIndex = -1;
    const MAX_CHECKPOINTS = 100;

    /**
     * Create an empty document structure
     */
    function createEmptyDoc() {
        return {
            meta: {
                version: SCHEMA_VERSION,
                lastModified: Date.now()
            },
            workspaces: {},
            subflows: {},
            nodes: {},
            groups: {},
            workspaceOrder: []
        };
    }

    /**
     * Convert flows array to document structure
     */
    function flowsToDoc(flows) {
        const docData = createEmptyDoc();

        if (!flows || !Array.isArray(flows)) {
            return docData;
        }

        const workspaceOrder = [];

        for (const node of flows) {
            if (node.type === 'tab') {
                docData.workspaces[node.id] = stripUndefined({ ...node });
                workspaceOrder.push(node.id);
            } else if (node.type === 'subflow') {
                docData.subflows[node.id] = stripUndefined({ ...node });
            } else if (node.type === 'group') {
                docData.groups[node.id] = stripUndefined({ ...node });
            } else {
                docData.nodes[node.id] = stripUndefined({ ...node });
            }
        }

        docData.workspaceOrder = workspaceOrder;
        docData.meta.lastModified = Date.now();

        return docData;
    }

    /**
     * Convert document to flows array
     */
    function docToFlows(docData) {
        const flows = [];

        if (!docData) {
            return flows;
        }

        // Add workspaces in order
        const workspaceOrder = docData.workspaceOrder || [];
        for (const wsId of workspaceOrder) {
            if (docData.workspaces && docData.workspaces[wsId]) {
                flows.push({ ...docData.workspaces[wsId] });
            }
        }

        // Add any workspaces not in workspaceOrder
        if (docData.workspaces) {
            for (const [id, workspace] of Object.entries(docData.workspaces)) {
                if (!workspaceOrder.includes(id)) {
                    flows.push({ ...workspace });
                }
            }
        }

        // Add subflows
        if (docData.subflows) {
            for (const subflow of Object.values(docData.subflows)) {
                flows.push({ ...subflow });
            }
        }

        // Add groups
        if (docData.groups) {
            for (const group of Object.values(docData.groups)) {
                flows.push({ ...group });
            }
        }

        // Add nodes
        if (docData.nodes) {
            for (const node of Object.values(docData.nodes)) {
                flows.push({ ...node });
            }
        }

        return flows;
    }

    /**
     * Initialize the Automerge client
     */
    async function init() {
        // Check if collaborative editing is enabled
        enabled = RED.settings.collaborativeEditing === true;

        if (!enabled) {
            console.log("Collaborative editing is disabled");
            return;
        }

        console.log("Initializing Automerge client for collaborative editing");

        // The IIFE bundle exposes window.Automerge but WASM loads async
        try {
            if (typeof window.Automerge !== 'undefined') {
                Automerge = window.Automerge;
            } else {
                console.warn("Automerge not found, collaborative editing disabled");
                enabled = false;
                return;
            }

            // Wait for WASM to be ready before using any Automerge functions
            if (typeof Automerge.wasmInitialized === 'function') {
                await Automerge.wasmInitialized();
                console.log("Automerge WASM initialized");
            }
        } catch (err) {
            console.error("Failed to load Automerge:", err);
            enabled = false;
            return;
        }

        // Doc starts null — will be loaded from server's init response
        doc = null;
        syncState = null;

        // Subscribe to sync messages
        RED.comms.subscribe("automerge/#", handleSyncMessage);

        // Connect handler - request initial sync
        RED.comms.on('connect', onConnect);

        initialized = true;

        // Request initial state (server will send full document)
        RED.comms.send('automerge/init', {});
    }

    /**
     * Handle connection established
     */
    function onConnect() {
        if (!enabled) return;

        console.log("Automerge: Connection established, requesting sync");
        // Reset sync state on reconnect
        syncState = Automerge.initSyncState();

        // Request initial state from server
        RED.comms.send('automerge/init', {});
    }

    /**
     * Handle incoming sync messages
     */
    function handleSyncMessage(topic, data) {
        if (!enabled || !Automerge) return;

        if (topic === 'automerge/init') {
            // Server sent the full document — load it to share history
            try {
                const binaryString = atob(data.document);
                const binary = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    binary[i] = binaryString.charCodeAt(i);
                }

                doc = Automerge.load(binary);
                syncState = Automerge.initSyncState();

                console.log("Automerge: Loaded document from server (v" + data.version + ")");

                // On init/reconnect, do NOT call applyRemoteChanges.
                // The editor already has the correct state; we just need
                // the shared document for future sync. Incremental changes
                // will arrive via automerge/sync messages.
            } catch (err) {
                console.error("Failed to load Automerge document from server:", err);
            }
        } else if (topic === 'automerge/sync') {
            if (!doc || !syncState) return; // Not yet initialized

            // Decode base64 message
            let syncMessage;
            try {
                const binaryString = atob(data.message);
                syncMessage = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    syncMessage[i] = binaryString.charCodeAt(i);
                }
            } catch (err) {
                console.error("Failed to decode sync message:", err);
                return;
            }

            // Apply sync message
            try {
                const oldDoc = doc;
                const [newDoc, newSyncState] = Automerge.receiveSyncMessage(
                    doc,
                    syncState,
                    syncMessage
                );

                doc = newDoc;
                syncState = newSyncState;

                // Generate response if needed
                const [nextSyncState, responseMessage] = Automerge.generateSyncMessage(
                    doc,
                    syncState
                );

                if (responseMessage) {
                    syncState = nextSyncState;
                    sendSyncMessage(responseMessage);
                }

                // If the document changed from remote, update the editor
                if (oldDoc !== newDoc) {
                    applyRemoteChanges(oldDoc, newDoc);
                }
            } catch (err) {
                console.error("Error processing sync message:", err);
            }
        }
    }

    /**
     * Send a sync message to the server
     */
    function sendSyncMessage(message) {
        if (!enabled || !message) return;

        // Encode as base64
        const binaryString = String.fromCharCode.apply(null, message);
        const base64 = btoa(binaryString);

        RED.comms.send('automerge/sync', { message: base64 });
    }

    /**
     * Apply local change and sync
     */
    function applyChange(description, changeFn) {
        if (!enabled || !doc || !Automerge) return;

        // Create checkpoint before change
        createCheckpoint();

        // Apply change
        doc = Automerge.change(doc, description, changeFn);

        // Generate and send sync message
        const [newSyncState, syncMessage] = Automerge.generateSyncMessage(doc, syncState);
        if (syncMessage) {
            syncState = newSyncState;
            sendSyncMessage(syncMessage);
        }
    }

    /**
     * Apply remote changes to the editor
     */
    function applyRemoteChanges(oldDoc, newDoc) {
        if (!enabled) return;

        // Analyze the differences and apply them to the editor
        const oldFlows = docToFlows(oldDoc);
        const newFlows = docToFlows(newDoc);

        // Build maps for comparison
        const oldNodeMap = {};
        oldFlows.forEach(function(n) { oldNodeMap[n.id] = n; });

        const newNodeMap = {};
        newFlows.forEach(function(n) { newNodeMap[n.id] = n; });

        const addedNodes = [];
        const updatedNodes = [];
        const removedNodes = [];

        // Check for added and updated nodes
        for (const id in newNodeMap) {
            if (!oldNodeMap[id]) {
                // Check if the node already exists in the editor (e.g. from init load)
                if (RED.nodes.node(id)) {
                    // Already in editor — treat as update instead of add
                    updatedNodes.push(newNodeMap[id]);
                } else {
                    addedNodes.push(newNodeMap[id]);
                }
            } else if (JSON.stringify(oldNodeMap[id]) !== JSON.stringify(newNodeMap[id])) {
                updatedNodes.push(newNodeMap[id]);
            }
        }

        // Check for removed nodes
        for (const id in oldNodeMap) {
            if (!newNodeMap[id]) {
                removedNodes.push(oldNodeMap[id]);
            }
        }

        // Apply changes to the editor (without triggering Automerge sync)
        if (removedNodes.length > 0 || addedNodes.length > 0 || updatedNodes.length > 0) {
            console.log("Remote changes - Added:", addedNodes.length, "Updated:", updatedNodes.length, "Removed:", removedNodes.length);

            // Remove nodes (each wrapped in try/catch for robustness)
            removedNodes.forEach(function(node) {
                try {
                    const existingNode = RED.nodes.node(node.id);
                    if (!existingNode) return;
                    if (existingNode.type === 'tab') {
                        RED.workspaces.remove(existingNode, true);
                    } else if (existingNode.type === 'subflow') {
                        RED.subflow.removeSubflow(node.id, true);
                    } else {
                        RED.nodes.remove(node.id);
                    }
                } catch (err) {
                    console.warn("Automerge: error removing node " + node.id + ":", err);
                }
            });

            // Add new nodes
            if (addedNodes.length > 0) {
                try {
                    RED.nodes.import(addedNodes, { generateIds: false, fromRemote: true });
                } catch (err) {
                    console.warn("Automerge: error importing nodes:", err);
                }
            }

            // Update existing nodes — only update changed properties, preserve internal state
            updatedNodes.forEach(function(nodeData) {
                try {
                    const existingNode = RED.nodes.node(nodeData.id);
                    if (!existingNode) return;
                    for (const key in nodeData) {
                        if (key === 'id' || key === 'type' || key === '_def' || key === '_') continue;
                        if (JSON.stringify(existingNode[key]) !== JSON.stringify(nodeData[key])) {
                            existingNode[key] = nodeData[key];
                        }
                    }
                    existingNode.dirty = true;
                    RED.events.emit("nodes:change", existingNode);
                } catch (err) {
                    console.warn("Automerge: error updating node " + nodeData.id + ":", err);
                }
            });

            // Redraw the workspace
            RED.view.redraw(true);
            RED.workspaces.refresh();
            RED.sidebar.config.refresh();
        }

        // Emit event for any additional handling
        RED.events.emit("automerge:remote-changes", {
            oldDoc: oldDoc,
            newDoc: newDoc,
            added: addedNodes,
            updated: updatedNodes,
            removed: removedNodes
        });
    }

    /**
     * Create a checkpoint for undo
     */
    function createCheckpoint() {
        if (!enabled || !doc) return;

        // Remove any checkpoints after current index (for redo branch)
        if (currentCheckpointIndex < checkpoints.length - 1) {
            checkpoints = checkpoints.slice(0, currentCheckpointIndex + 1);
        }

        // Save current state
        checkpoints.push(Automerge.save(doc));
        currentCheckpointIndex = checkpoints.length - 1;

        // Limit checkpoint history
        if (checkpoints.length > MAX_CHECKPOINTS) {
            checkpoints.shift();
            currentCheckpointIndex--;
        }
    }

    /**
     * Check if undo is available
     */
    function canUndo() {
        return enabled && currentCheckpointIndex > 0;
    }

    /**
     * Check if redo is available
     */
    function canRedo() {
        return enabled && currentCheckpointIndex < checkpoints.length - 1;
    }

    /**
     * Undo to previous checkpoint
     */
    function undo() {
        if (!canUndo()) return null;

        currentCheckpointIndex--;
        doc = Automerge.load(checkpoints[currentCheckpointIndex]);

        // Sync the restored state
        const [newSyncState, syncMessage] = Automerge.generateSyncMessage(doc, syncState);
        if (syncMessage) {
            syncState = newSyncState;
            sendSyncMessage(syncMessage);
        }

        return docToFlows(doc);
    }

    /**
     * Redo to next checkpoint
     */
    function redo() {
        if (!canRedo()) return null;

        currentCheckpointIndex++;
        doc = Automerge.load(checkpoints[currentCheckpointIndex]);

        // Sync the restored state
        const [newSyncState, syncMessage] = Automerge.generateSyncMessage(doc, syncState);
        if (syncMessage) {
            syncState = newSyncState;
            sendSyncMessage(syncMessage);
        }

        return docToFlows(doc);
    }

    // =============================
    // Node Operations
    // =============================

    /**
     * Add a node to the document
     */
    function addNode(node) {
        if (!enabled) return;

        applyChange('Add node: ' + node.id, (d) => {
            const type = node.type;

            if (type === 'tab') {
                d.workspaces[node.id] = stripUndefined({ ...node });
                if (!d.workspaceOrder.includes(node.id)) {
                    d.workspaceOrder.push(node.id);
                }
            } else if (type === 'subflow') {
                d.subflows[node.id] = stripUndefined({ ...node });
            } else if (type === 'group') {
                d.groups[node.id] = stripUndefined({ ...node });
            } else {
                d.nodes[node.id] = stripUndefined({ ...node });
            }

            d.meta.lastModified = Date.now();
        });
    }

    /**
     * Remove a node from the document
     */
    function removeNode(id, type) {
        if (!enabled) return;

        applyChange('Remove node: ' + id, (d) => {
            if (type === 'tab' || (d.workspaces && d.workspaces[id])) {
                delete d.workspaces[id];
                const idx = d.workspaceOrder.indexOf(id);
                if (idx !== -1) {
                    d.workspaceOrder.splice(idx, 1);
                }
            } else if (type === 'subflow' || (d.subflows && d.subflows[id])) {
                delete d.subflows[id];
            } else if (type === 'group' || (d.groups && d.groups[id])) {
                delete d.groups[id];
            } else if (d.nodes && d.nodes[id]) {
                delete d.nodes[id];
            }

            d.meta.lastModified = Date.now();
        });
    }

    /**
     * Update a node in the document
     */
    function updateNode(id, updates) {
        if (!enabled) return;

        applyChange('Update node: ' + id, (d) => {
            let target = null;

            if (d.nodes && d.nodes[id]) {
                target = d.nodes[id];
            } else if (d.workspaces && d.workspaces[id]) {
                target = d.workspaces[id];
            } else if (d.subflows && d.subflows[id]) {
                target = d.subflows[id];
            } else if (d.groups && d.groups[id]) {
                target = d.groups[id];
            }

            if (target) {
                const cleanUpdates = stripUndefined(updates);
                for (const [key, value] of Object.entries(cleanUpdates)) {
                    target[key] = value;
                }
                d.meta.lastModified = Date.now();
            }
        });
    }

    /**
     * Update node position
     */
    function updateNodePosition(id, x, y) {
        if (!enabled) return;

        applyChange('Move node: ' + id, (d) => {
            if (d.nodes && d.nodes[id]) {
                d.nodes[id].x = x;
                d.nodes[id].y = y;
                d.meta.lastModified = Date.now();
            }
        });
    }

    /**
     * Batch update positions for multiple nodes in a single Automerge change
     */
    function batchPositionUpdate(nodes) {
        if (!enabled || !nodes || nodes.length === 0) return;

        applyChange('Move ' + nodes.length + ' nodes', (d) => {
            for (const n of nodes) {
                if (d.nodes && d.nodes[n.id]) {
                    d.nodes[n.id].x = n.x;
                    d.nodes[n.id].y = n.y;
                } else if (d.groups && d.groups[n.id]) {
                    d.groups[n.id].x = n.x;
                    d.groups[n.id].y = n.y;
                }
            }
            d.meta.lastModified = Date.now();
        });
    }

    /**
     * Update wires for a node
     */
    function updateWires(nodeId, wires) {
        if (!enabled) return;

        applyChange('Update wires: ' + nodeId, (d) => {
            if (d.nodes && d.nodes[nodeId]) {
                // Normalize wires to ensure consistent ordering
                const normalizedWires = wires.map(outputWires => {
                    if (!Array.isArray(outputWires)) return [];
                    return [...new Set(outputWires)].sort();
                });
                d.nodes[nodeId].wires = normalizedWires;
                d.meta.lastModified = Date.now();
            }
        });
    }

    /**
     * Add a wire connection
     */
    function addWire(sourceId, sourcePort, targetId) {
        if (!enabled) return;

        applyChange('Add wire', (d) => {
            if (!d.nodes || !d.nodes[sourceId]) return;

            const node = d.nodes[sourceId];
            if (!node.wires) {
                node.wires = [];
            }

            while (node.wires.length <= sourcePort) {
                node.wires.push([]);
            }

            if (!node.wires[sourcePort].includes(targetId)) {
                node.wires[sourcePort].push(targetId);
            }

            d.meta.lastModified = Date.now();
        });
    }

    /**
     * Remove a wire connection
     */
    function removeWire(sourceId, sourcePort, targetId) {
        if (!enabled) return;

        applyChange('Remove wire', (d) => {
            if (!d.nodes || !d.nodes[sourceId]) return;

            const node = d.nodes[sourceId];
            if (!node.wires || !node.wires[sourcePort]) return;

            const idx = node.wires[sourcePort].indexOf(targetId);
            if (idx !== -1) {
                node.wires[sourcePort].splice(idx, 1);
            }

            d.meta.lastModified = Date.now();
        });
    }

    /**
     * Move workspace in order
     */
    function moveWorkspace(workspaceId, newIndex) {
        if (!enabled) return;

        applyChange('Move workspace', (d) => {
            const currentIndex = d.workspaceOrder.indexOf(workspaceId);
            if (currentIndex === -1) return;

            d.workspaceOrder.splice(currentIndex, 1);
            d.workspaceOrder.splice(newIndex, 0, workspaceId);
            d.meta.lastModified = Date.now();
        });
    }

    /**
     * Set the workspace order
     */
    function setWorkspaceOrder(order) {
        if (!enabled || !order) return;

        applyChange('Reorder workspaces', (d) => {
            d.workspaceOrder.splice(0, d.workspaceOrder.length);
            for (const wsId of order) {
                // Only include workspace IDs that exist in the doc
                if (d.workspaces && d.workspaces[wsId]) {
                    d.workspaceOrder.push(wsId);
                }
            }
            d.meta.lastModified = Date.now();
        });
    }

    /**
     * Add node to group
     */
    function addNodeToGroup(groupId, nodeId) {
        if (!enabled) return;

        applyChange('Add to group', (d) => {
            if (!d.groups || !d.groups[groupId]) return;

            const group = d.groups[groupId];
            if (!group.nodes) {
                group.nodes = [];
            }

            if (!group.nodes.includes(nodeId)) {
                group.nodes.push(nodeId);
            }

            if (d.nodes && d.nodes[nodeId]) {
                d.nodes[nodeId].g = groupId;
            }

            d.meta.lastModified = Date.now();
        });
    }

    /**
     * Remove node from group
     */
    function removeNodeFromGroup(groupId, nodeId) {
        if (!enabled) return;

        applyChange('Remove from group', (d) => {
            if (!d.groups || !d.groups[groupId]) return;

            const group = d.groups[groupId];
            if (!group.nodes) return;

            const idx = group.nodes.indexOf(nodeId);
            if (idx !== -1) {
                group.nodes.splice(idx, 1);
            }

            if (d.nodes && d.nodes[nodeId]) {
                delete d.nodes[nodeId].g;
            }

            d.meta.lastModified = Date.now();
        });
    }

    /**
     * Get current flows from document
     */
    function getFlows() {
        if (!enabled || !doc) return null;
        return docToFlows(doc);
    }

    /**
     * Set flows (replaces entire document)
     */
    function setFlows(flows) {
        if (!enabled || !doc || !Automerge) return;

        createCheckpoint();

        applyChange('Set flows', (d) => {
            const newDocData = flowsToDoc(flows);

            // Clear existing data
            for (const key of Object.keys(d.workspaces)) {
                delete d.workspaces[key];
            }
            for (const key of Object.keys(d.subflows)) {
                delete d.subflows[key];
            }
            for (const key of Object.keys(d.nodes)) {
                delete d.nodes[key];
            }
            for (const key of Object.keys(d.groups)) {
                delete d.groups[key];
            }
            d.workspaceOrder.splice(0, d.workspaceOrder.length);

            // Copy new data
            for (const [key, value] of Object.entries(newDocData.workspaces)) {
                d.workspaces[key] = value;
            }
            for (const [key, value] of Object.entries(newDocData.subflows)) {
                d.subflows[key] = value;
            }
            for (const [key, value] of Object.entries(newDocData.nodes)) {
                d.nodes[key] = value;
            }
            for (const [key, value] of Object.entries(newDocData.groups)) {
                d.groups[key] = value;
            }
            for (const wsId of newDocData.workspaceOrder) {
                d.workspaceOrder.push(wsId);
            }

            d.meta.lastModified = Date.now();
        });
    }

    /**
     * Check if enabled
     */
    function isEnabled() {
        return enabled;
    }

    /**
     * Get document for external access
     */
    function getDocument() {
        return doc;
    }

    return {
        init: init,
        isEnabled: isEnabled,
        getDocument: getDocument,
        getFlows: getFlows,
        setFlows: setFlows,

        // Node operations
        addNode: addNode,
        removeNode: removeNode,
        updateNode: updateNode,
        updateNodePosition: updateNodePosition,
        updateWires: updateWires,
        addWire: addWire,
        removeWire: removeWire,

        // Workspace operations
        moveWorkspace: moveWorkspace,
        setWorkspaceOrder: setWorkspaceOrder,
        batchPositionUpdate: batchPositionUpdate,

        // Group operations
        addNodeToGroup: addNodeToGroup,
        removeNodeFromGroup: removeNodeFromGroup,

        // Undo/redo
        canUndo: canUndo,
        canRedo: canRedo,
        undo: undo,
        redo: redo,
        createCheckpoint: createCheckpoint,

        // For direct change application
        applyChange: applyChange
    };
})();
