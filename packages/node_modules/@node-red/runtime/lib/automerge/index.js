/**
 * Copyright JS Foundation and other contributors, http://js.foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

/**
 * Automerge Sync Server for Node-RED
 *
 * Manages the server-side Automerge document and synchronization
 * with connected editor clients.
 */

const Automerge = require('@automerge/automerge');
const schema = require('./schema');
const fs = require('fs-extra');
const fspath = require('path');

let runtime;
let settings;
let doc = null;
let syncStates = new Map(); // Map of session -> Automerge.SyncState
let automergeFilePath = null;
let saveTimer = null;
let enabled = false;

const SAVE_DEBOUNCE_MS = 2000;

/**
 * Initialize the Automerge sync server
 * @param {Object} _runtime - Node-RED runtime reference
 */
function init(_runtime) {
    runtime = _runtime;
    settings = runtime.settings;

    // Check if collaborative editing is enabled
    enabled = settings.collaborativeEditing === true;

    if (!enabled) {
        runtime.log.info("Collaborative editing is disabled");
        return;
    }

    runtime.log.info("Collaborative editing (Automerge) enabled");

    // Set up event listeners for sync messages
    runtime.events.on('comms:message:automerge/sync', handleSyncMessage);
    runtime.events.on('comms:message:automerge/init', handleInitRequest);
    runtime.events.on('comms:connection-removed', handleConnectionRemoved);
}

/**
 * Check if collaborative editing is enabled
 * @returns {boolean}
 */
function isEnabled() {
    return enabled;
}

/**
 * Load or create the Automerge document
 * @param {string} userDir - User directory path
 * @param {Array} flows - Initial flows to convert if no doc exists
 * @returns {Promise<void>}
 */
async function loadDocument(userDir, flows) {
    if (!enabled) return;

    automergeFilePath = fspath.join(userDir, 'flows.automerge');

    try {
        // Try to load existing Automerge document
        const exists = await fs.pathExists(automergeFilePath);
        if (exists) {
            const binary = await fs.readFile(automergeFilePath);
            doc = Automerge.load(binary);
            runtime.log.info("Loaded existing Automerge document");
        } else {
            // Create new document from existing flows
            doc = Automerge.from(schema.flowsToDoc(flows || []));
            runtime.log.info("Created new Automerge document from flows");
            await saveDocument();
        }
    } catch (err) {
        runtime.log.warn("Failed to load Automerge document, creating new: " + err.message);
        doc = Automerge.from(schema.flowsToDoc(flows || []));
        await saveDocument();
    }
}

/**
 * Save the Automerge document to disk
 * @returns {Promise<void>}
 */
async function saveDocument() {
    if (!enabled || !doc || !automergeFilePath || settings.readOnly) return;

    try {
        const binary = Automerge.save(doc);
        await fs.writeFile(automergeFilePath, Buffer.from(binary));
        runtime.log.trace("Saved Automerge document");
    } catch (err) {
        runtime.log.error("Failed to save Automerge document: " + err.message);
    }
}

/**
 * Schedule a debounced save
 */
function scheduleSave() {
    if (saveTimer) {
        clearTimeout(saveTimer);
    }
    saveTimer = setTimeout(() => {
        saveDocument();
        saveTimer = null;
    }, SAVE_DEBOUNCE_MS);
}

/**
 * Get the current document
 * @returns {Object} Automerge document
 */
function getDocument() {
    return doc;
}

/**
 * Get flows array from the current document
 * @returns {Array} Flow nodes array
 */
function getFlows() {
    if (!doc) return [];
    return schema.docToFlows(doc);
}

/**
 * Update the document from a new flows array (e.g., on deploy)
 * @param {Array} flows - Flow nodes array
 */
function setFlows(flows) {
    if (!enabled || !doc) return;

    doc = Automerge.change(doc, 'Update flows', (d) => {
        const newDoc = schema.flowsToDoc(flows);

        // Clear existing data
        for (const key of Object.keys(d.workspaces)) {
            delete d.workspaces[key];
        }
        for (const key of Object.keys(d.subflows)) {
            delete d.subflows[key];
        }
        for (const key of Object.keys(d.nodes)) {
            delete d.nodes[key];
        }
        for (const key of Object.keys(d.groups)) {
            delete d.groups[key];
        }
        d.workspaceOrder.length = 0;

        // Copy new data
        for (const [key, value] of Object.entries(newDoc.workspaces)) {
            d.workspaces[key] = value;
        }
        for (const [key, value] of Object.entries(newDoc.subflows)) {
            d.subflows[key] = value;
        }
        for (const [key, value] of Object.entries(newDoc.nodes)) {
            d.nodes[key] = value;
        }
        for (const [key, value] of Object.entries(newDoc.groups)) {
            d.groups[key] = value;
        }
        for (const wsId of newDoc.workspaceOrder) {
            d.workspaceOrder.push(wsId);
        }

        d.meta.lastModified = Date.now();
    });

    // Broadcast sync to all connected clients
    broadcastSync();
    scheduleSave();
}

/**
 * Apply changes from a client
 * @param {string} session - Client session ID
 * @param {Uint8Array} syncMessage - Automerge sync message
 * @returns {Uint8Array|null} Response sync message
 */
function receiveSyncMessage(session, syncMessage) {
    if (!enabled || !doc) return null;

    let syncState = syncStates.get(session);
    if (!syncState) {
        syncState = Automerge.initSyncState();
    }

    try {
        const [newDoc, newSyncState, patch] = Automerge.receiveSyncMessage(
            doc,
            syncState,
            syncMessage
        );

        doc = newDoc;
        syncStates.set(session, newSyncState);

        // Generate response message
        const [nextSyncState, responseMessage] = Automerge.generateSyncMessage(
            doc,
            newSyncState
        );

        if (responseMessage) {
            syncStates.set(session, nextSyncState);
        }

        // If there were changes, save and notify other clients
        if (patch) {
            scheduleSave();
            broadcastSyncExcept(session);
        }

        return responseMessage;
    } catch (err) {
        runtime.log.warn("Error processing sync message: " + err.message);
        return null;
    }
}

/**
 * Generate a sync message for a client
 * @param {string} session - Client session ID
 * @returns {Uint8Array|null} Sync message
 */
function generateSyncMessage(session) {
    if (!enabled || !doc) return null;

    let syncState = syncStates.get(session);
    if (!syncState) {
        syncState = Automerge.initSyncState();
    }

    const [newSyncState, message] = Automerge.generateSyncMessage(doc, syncState);
    syncStates.set(session, newSyncState);

    return message;
}

/**
 * Handle incoming sync message from comms
 * @param {Object} opts - Message options
 */
function handleSyncMessage(opts) {
    if (!enabled) return;

    const { session, data } = opts;

    // Decode base64 sync message
    let syncMessage;
    try {
        syncMessage = new Uint8Array(Buffer.from(data.message, 'base64'));
    } catch (err) {
        runtime.log.warn("Invalid sync message format");
        return;
    }

    const response = receiveSyncMessage(session, syncMessage);

    if (response) {
        runtime.events.emit('comms', {
            topic: 'automerge/sync',
            data: {
                message: Buffer.from(response).toString('base64')
            },
            session: session
        });
    }
}

/**
 * Handle init request from a new client
 * @param {Object} opts - Message options
 */
function handleInitRequest(opts) {
    if (!enabled) return;

    const { session } = opts;

    // Reset sync state for this client
    syncStates.set(session, Automerge.initSyncState());

    // Generate initial sync message
    const message = generateSyncMessage(session);

    if (message) {
        runtime.events.emit('comms', {
            topic: 'automerge/sync',
            data: {
                message: Buffer.from(message).toString('base64')
            },
            session: session
        });
    }

    // Also send current state info
    runtime.events.emit('comms', {
        topic: 'automerge/state',
        data: {
            enabled: true,
            version: schema.SCHEMA_VERSION
        },
        session: session
    });
}

/**
 * Handle connection removed
 * @param {Object} opts - Event options
 */
function handleConnectionRemoved(opts) {
    syncStates.delete(opts.session);
}

/**
 * Broadcast sync to all connected clients
 */
function broadcastSync() {
    if (!enabled || !doc) return;

    for (const [session] of syncStates) {
        const message = generateSyncMessage(session);
        if (message) {
            runtime.events.emit('comms', {
                topic: 'automerge/sync',
                data: {
                    message: Buffer.from(message).toString('base64')
                },
                session: session
            });
        }
    }
}

/**
 * Broadcast sync to all clients except one
 * @param {string} excludeSession - Session to exclude
 */
function broadcastSyncExcept(excludeSession) {
    if (!enabled || !doc) return;

    for (const [session] of syncStates) {
        if (session === excludeSession) continue;

        const message = generateSyncMessage(session);
        if (message) {
            runtime.events.emit('comms', {
                topic: 'automerge/sync',
                data: {
                    message: Buffer.from(message).toString('base64')
                },
                session: session
            });
        }
    }
}

/**
 * Apply a local change to the document
 * @param {string} description - Change description
 * @param {Function} changeFn - Function that modifies the document
 */
function applyChange(description, changeFn) {
    if (!enabled || !doc) return;

    doc = Automerge.change(doc, description, changeFn);
    broadcastSync();
    scheduleSave();
}

/**
 * Get document history
 * @returns {Array} Array of change objects
 */
function getHistory() {
    if (!doc) return [];
    return Automerge.getHistory(doc);
}

/**
 * Create a checkpoint/snapshot
 * @returns {Uint8Array} Binary snapshot
 */
function createSnapshot() {
    if (!doc) return null;
    return Automerge.save(doc);
}

/**
 * Restore from a snapshot
 * @param {Uint8Array} snapshot - Binary snapshot
 */
function restoreSnapshot(snapshot) {
    if (!enabled) return;

    try {
        doc = Automerge.load(snapshot);
        broadcastSync();
        scheduleSave();
    } catch (err) {
        runtime.log.error("Failed to restore snapshot: " + err.message);
    }
}

module.exports = {
    init,
    isEnabled,
    loadDocument,
    saveDocument,
    getDocument,
    getFlows,
    setFlows,
    receiveSyncMessage,
    generateSyncMessage,
    applyChange,
    getHistory,
    createSnapshot,
    restoreSnapshot,
    schema
};
