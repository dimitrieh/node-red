/**
 * Copyright JS Foundation and other contributors, http://js.foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/

/**
 * Automerge Document Schema for Node-RED Flows
 *
 * Schema structure:
 * {
 *   meta: { version: "1.0", lastModified: <timestamp> },
 *   workspaces: { "<id>": { id, type: "tab", label, ... } },
 *   subflows: { "<id>": { id, type: "subflow", name, ... } },
 *   nodes: { "<id>": { id, type, z, x, y, wires, ... } },
 *   groups: { "<id>": { id, type: "group", z, nodes, ... } },
 *   workspaceOrder: ["<workspace-id>", ...]
 * }
 */

const SCHEMA_VERSION = "1.0";

/**
 * Create an empty Automerge document structure
 * @returns {Object} Empty document structure
 */
function createEmptyDoc() {
    return {
        meta: {
            version: SCHEMA_VERSION,
            lastModified: Date.now()
        },
        workspaces: {},
        subflows: {},
        nodes: {},
        groups: {},
        workspaceOrder: []
    };
}

/**
 * Convert a Node-RED flow array to Automerge document structure
 * @param {Array} flows - Array of flow nodes from Node-RED
 * @returns {Object} Document structure for Automerge
 */
function flowsToDoc(flows) {
    const doc = createEmptyDoc();

    if (!flows || !Array.isArray(flows)) {
        return doc;
    }

    // First pass: identify workspaces and subflows
    const workspaceOrder = [];

    for (const node of flows) {
        if (node.type === 'tab') {
            doc.workspaces[node.id] = { ...node };
            workspaceOrder.push(node.id);
        } else if (node.type === 'subflow') {
            doc.subflows[node.id] = { ...node };
        } else if (node.type === 'group') {
            doc.groups[node.id] = { ...node };
        } else {
            doc.nodes[node.id] = { ...node };
        }
    }

    doc.workspaceOrder = workspaceOrder;
    doc.meta.lastModified = Date.now();

    return doc;
}

/**
 * Convert an Automerge document to Node-RED flow array
 * @param {Object} doc - Automerge document
 * @returns {Array} Array of flow nodes for Node-RED
 */
function docToFlows(doc) {
    const flows = [];

    if (!doc) {
        return flows;
    }

    // Add workspaces in order
    const workspaceOrder = doc.workspaceOrder || [];
    for (const wsId of workspaceOrder) {
        if (doc.workspaces && doc.workspaces[wsId]) {
            flows.push({ ...doc.workspaces[wsId] });
        }
    }

    // Add any workspaces not in workspaceOrder
    if (doc.workspaces) {
        for (const [id, workspace] of Object.entries(doc.workspaces)) {
            if (!workspaceOrder.includes(id)) {
                flows.push({ ...workspace });
            }
        }
    }

    // Add subflows
    if (doc.subflows) {
        for (const subflow of Object.values(doc.subflows)) {
            flows.push({ ...subflow });
        }
    }

    // Add groups
    if (doc.groups) {
        for (const group of Object.values(doc.groups)) {
            flows.push({ ...group });
        }
    }

    // Add nodes
    if (doc.nodes) {
        for (const node of Object.values(doc.nodes)) {
            flows.push({ ...node });
        }
    }

    return flows;
}

/**
 * Get a node from the document by ID
 * @param {Object} doc - Automerge document
 * @param {string} id - Node ID
 * @returns {Object|null} Node object or null if not found
 */
function getNode(doc, id) {
    if (!doc || !id) return null;

    if (doc.nodes && doc.nodes[id]) {
        return doc.nodes[id];
    }
    if (doc.workspaces && doc.workspaces[id]) {
        return doc.workspaces[id];
    }
    if (doc.subflows && doc.subflows[id]) {
        return doc.subflows[id];
    }
    if (doc.groups && doc.groups[id]) {
        return doc.groups[id];
    }

    return null;
}

/**
 * Set/update a node in the document
 * @param {Object} doc - Automerge document (mutable in change callback)
 * @param {Object} node - Node to set
 */
function setNode(doc, node) {
    if (!doc || !node || !node.id) return;

    const type = node.type;

    if (type === 'tab') {
        doc.workspaces[node.id] = { ...node };
        if (!doc.workspaceOrder.includes(node.id)) {
            doc.workspaceOrder.push(node.id);
        }
    } else if (type === 'subflow') {
        doc.subflows[node.id] = { ...node };
    } else if (type === 'group') {
        doc.groups[node.id] = { ...node };
    } else {
        doc.nodes[node.id] = { ...node };
    }

    doc.meta.lastModified = Date.now();
}

/**
 * Delete a node from the document
 * @param {Object} doc - Automerge document (mutable in change callback)
 * @param {string} id - Node ID to delete
 * @param {string} type - Node type (optional, helps find the right collection)
 */
function deleteNode(doc, id, type) {
    if (!doc || !id) return;

    if (type === 'tab' || (doc.workspaces && doc.workspaces[id])) {
        delete doc.workspaces[id];
        const idx = doc.workspaceOrder.indexOf(id);
        if (idx !== -1) {
            doc.workspaceOrder.splice(idx, 1);
        }
    } else if (type === 'subflow' || (doc.subflows && doc.subflows[id])) {
        delete doc.subflows[id];
    } else if (type === 'group' || (doc.groups && doc.groups[id])) {
        delete doc.groups[id];
    } else if (doc.nodes && doc.nodes[id]) {
        delete doc.nodes[id];
    }

    doc.meta.lastModified = Date.now();
}

/**
 * Update specific properties of a node
 * @param {Object} doc - Automerge document (mutable in change callback)
 * @param {string} id - Node ID
 * @param {Object} updates - Properties to update
 */
function updateNode(doc, id, updates) {
    const node = getNode(doc, id);
    if (!node) return;

    const type = node.type;
    let target;

    if (type === 'tab') {
        target = doc.workspaces[id];
    } else if (type === 'subflow') {
        target = doc.subflows[id];
    } else if (type === 'group') {
        target = doc.groups[id];
    } else {
        target = doc.nodes[id];
    }

    if (target) {
        for (const [key, value] of Object.entries(updates)) {
            target[key] = value;
        }
        doc.meta.lastModified = Date.now();
    }
}

/**
 * Update wires for a node (handles wire array as a Set-like structure)
 * @param {Object} doc - Automerge document (mutable in change callback)
 * @param {string} nodeId - Node ID
 * @param {Array} wires - New wires array
 */
function updateWires(doc, nodeId, wires) {
    if (!doc || !nodeId || !doc.nodes || !doc.nodes[nodeId]) return;

    // Normalize wires to ensure consistent ordering
    const normalizedWires = wires.map(outputWires => {
        if (!Array.isArray(outputWires)) return [];
        // Sort target IDs for deterministic ordering
        return [...new Set(outputWires)].sort();
    });

    doc.nodes[nodeId].wires = normalizedWires;
    doc.meta.lastModified = Date.now();
}

/**
 * Add a wire connection
 * @param {Object} doc - Automerge document (mutable in change callback)
 * @param {string} sourceId - Source node ID
 * @param {number} sourcePort - Source output port index
 * @param {string} targetId - Target node ID
 */
function addWire(doc, sourceId, sourcePort, targetId) {
    if (!doc || !doc.nodes || !doc.nodes[sourceId]) return;

    const node = doc.nodes[sourceId];
    if (!node.wires) {
        node.wires = [];
    }

    // Ensure the output port array exists
    while (node.wires.length <= sourcePort) {
        node.wires.push([]);
    }

    // Add the target if not already present
    if (!node.wires[sourcePort].includes(targetId)) {
        node.wires[sourcePort].push(targetId);
        node.wires[sourcePort].sort(); // Maintain sorted order
    }

    doc.meta.lastModified = Date.now();
}

/**
 * Remove a wire connection
 * @param {Object} doc - Automerge document (mutable in change callback)
 * @param {string} sourceId - Source node ID
 * @param {number} sourcePort - Source output port index
 * @param {string} targetId - Target node ID
 */
function removeWire(doc, sourceId, sourcePort, targetId) {
    if (!doc || !doc.nodes || !doc.nodes[sourceId]) return;

    const node = doc.nodes[sourceId];
    if (!node.wires || !node.wires[sourcePort]) return;

    const idx = node.wires[sourcePort].indexOf(targetId);
    if (idx !== -1) {
        node.wires[sourcePort].splice(idx, 1);
    }

    doc.meta.lastModified = Date.now();
}

/**
 * Move workspace to a new position in the order
 * @param {Object} doc - Automerge document (mutable in change callback)
 * @param {string} workspaceId - Workspace ID to move
 * @param {number} newIndex - New index position
 */
function moveWorkspace(doc, workspaceId, newIndex) {
    if (!doc || !doc.workspaceOrder) return;

    const currentIndex = doc.workspaceOrder.indexOf(workspaceId);
    if (currentIndex === -1) return;

    doc.workspaceOrder.splice(currentIndex, 1);
    doc.workspaceOrder.splice(newIndex, 0, workspaceId);
    doc.meta.lastModified = Date.now();
}

/**
 * Add node to a group
 * @param {Object} doc - Automerge document (mutable in change callback)
 * @param {string} groupId - Group ID
 * @param {string} nodeId - Node ID to add to group
 */
function addNodeToGroup(doc, groupId, nodeId) {
    if (!doc || !doc.groups || !doc.groups[groupId]) return;

    const group = doc.groups[groupId];
    if (!group.nodes) {
        group.nodes = [];
    }

    if (!group.nodes.includes(nodeId)) {
        group.nodes.push(nodeId);
    }

    // Update the node's group reference
    const node = getNode(doc, nodeId);
    if (node && doc.nodes && doc.nodes[nodeId]) {
        doc.nodes[nodeId].g = groupId;
    }

    doc.meta.lastModified = Date.now();
}

/**
 * Remove node from a group
 * @param {Object} doc - Automerge document (mutable in change callback)
 * @param {string} groupId - Group ID
 * @param {string} nodeId - Node ID to remove from group
 */
function removeNodeFromGroup(doc, groupId, nodeId) {
    if (!doc || !doc.groups || !doc.groups[groupId]) return;

    const group = doc.groups[groupId];
    if (!group.nodes) return;

    const idx = group.nodes.indexOf(nodeId);
    if (idx !== -1) {
        group.nodes.splice(idx, 1);
    }

    // Remove the node's group reference
    if (doc.nodes && doc.nodes[nodeId]) {
        delete doc.nodes[nodeId].g;
    }

    doc.meta.lastModified = Date.now();
}

module.exports = {
    SCHEMA_VERSION,
    createEmptyDoc,
    flowsToDoc,
    docToFlows,
    getNode,
    setNode,
    deleteNode,
    updateNode,
    updateWires,
    addWire,
    removeWire,
    moveWorkspace,
    addNodeToGroup,
    removeNodeFromGroup
};
