name: Deploy to Hetzner

on:
  push:
    branches:
      - "issue-*"
      - "claude/*"
      - "experiment-*"
      - "experiment-template"
  workflow_dispatch:
    inputs:
      branch:
        description: "Branch to deploy"
        required: true
        default: "experiment-template"
        type: string
      action:
        description: "Deployment action"
        required: true
        default: "deploy"
        type: choice
        options:
          - deploy
          - cleanup
          - cleanup-with-dashboard

permissions:
  contents: read
  issues: write # Required for posting comments to issues
  pull-requests: write # Required for posting comments to PRs

# Global environment variables
env:
  GITHUB_REPO: ${{ vars.GITHUB_REPO || 'dimitrieh/node-red' }}
  GITHUB_ISSUES_REPO: ${{ vars.GITHUB_ISSUES_REPO || 'node-red/node-red' }}

jobs:
  validate-branch:
    name: Validate Branch Rebase
    runs-on: ubuntu-latest
    outputs:
      branch_valid: ${{ steps.validate.outputs.valid }}
      validation_message: ${{ steps.validate.outputs.message }}
      needs_rebase: ${{ steps.validate.outputs.needs_rebase }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ github.token }}

      - name: Fetch all branches
        run: |
          git fetch --all --prune
          echo "Available branches:"
          git branch -a

      - name: Validate branch rebase on experiment-template
        id: validate
        shell: bash
        env:
          BRANCH_NAME: ${{ github.event.inputs.branch || github.ref_name }}
          BASE_BRANCH: experiment-template
        run: |
          set -euo pipefail

          echo "::group::üîç Validating branch: $BRANCH_NAME"
          echo "üìã Base branch: $BASE_BRANCH"

          # Check if target branch exists
          if ! git show-ref --verify --quiet "refs/remotes/origin/$BRANCH_NAME"; then
            echo "::error::Branch '$BRANCH_NAME' does not exist on remote"
            echo "valid=false" >> "$GITHUB_OUTPUT"
            echo "needs_rebase=false" >> "$GITHUB_OUTPUT"
            echo "message=Branch '$BRANCH_NAME' does not exist on remote" >> "$GITHUB_OUTPUT"
            echo "::endgroup::"
            exit 0
          fi

          # Check if base branch exists
          if ! git show-ref --verify --quiet "refs/remotes/origin/$BASE_BRANCH"; then
            echo "::error::Base branch '$BASE_BRANCH' does not exist on remote"
            echo "valid=false" >> "$GITHUB_OUTPUT"
            echo "needs_rebase=false" >> "$GITHUB_OUTPUT"
            echo "message=Base branch '$BASE_BRANCH' does not exist on remote" >> "$GITHUB_OUTPUT"
            echo "::endgroup::"
            exit 0
          fi

          # Get latest commits
          git checkout "origin/$BASE_BRANCH"
          BASE_COMMIT=$(git rev-parse HEAD)

          git checkout "origin/$BRANCH_NAME"
          BRANCH_COMMIT=$(git rev-parse HEAD)

          echo "üìç Base branch ($BASE_BRANCH) latest commit: $BASE_COMMIT"
          echo "üìç Target branch ($BRANCH_NAME) latest commit: $BRANCH_COMMIT"

          # Check if base branch is ancestor of target branch
          if ! git merge-base --is-ancestor "$BASE_COMMIT" "$BRANCH_COMMIT"; then
            echo "::warning::Branch '$BRANCH_NAME' is not rebased on latest '$BASE_BRANCH'"
            echo "::notice::Branch needs automatic rebase"
            echo "valid=false" >> "$GITHUB_OUTPUT"
            echo "needs_rebase=true" >> "$GITHUB_OUTPUT"
            echo "message=Branch '$BRANCH_NAME' needs rebase on latest '$BASE_BRANCH'. Attempting automatic rebase..." >> "$GITHUB_OUTPUT"
            echo "::endgroup::"
            exit 0
          fi

          # Check for merge commits from base branch (indicates merge instead of rebase)
          MERGE_COMMITS=$(git log --oneline --merges "$BASE_COMMIT..$BRANCH_COMMIT" --grep="Merge.*$BASE_BRANCH" | wc -l || echo "0")
          if [ "$MERGE_COMMITS" -gt 0 ]; then
            echo "::warning::Found $MERGE_COMMITS merge commit(s) from '$BASE_BRANCH'"
            echo "üí° Consider using rebase instead of merge for cleaner history"
            # Note: This is a warning, not a failure
          fi

          # Get the merge base to check how recent the rebase is
          MERGE_BASE=$(git merge-base "origin/$BASE_BRANCH" "origin/$BRANCH_NAME")
          COMMITS_BEHIND=$(git rev-list --count "$MERGE_BASE..origin/$BASE_BRANCH" || echo "0")

          if [ "$COMMITS_BEHIND" -gt 0 ]; then
            echo "::warning::Branch '$BRANCH_NAME' is $COMMITS_BEHIND commit(s) behind latest '$BASE_BRANCH'"
            echo "üí° Consider rebasing to include latest changes: git rebase origin/$BASE_BRANCH"
            # Note: This is a warning, not a failure for now
          fi

          # All validations passed
          echo "‚úÖ Branch '$BRANCH_NAME' is properly rebased on '$BASE_BRANCH'"
          echo "üìä Commits behind base: $COMMITS_BEHIND"
          echo "üéØ Ready for deployment"
          echo "::endgroup::"

          echo "valid=true" >> "$GITHUB_OUTPUT"
          echo "needs_rebase=false" >> "$GITHUB_OUTPUT"
          echo "message=Branch '$BRANCH_NAME' is properly rebased and ready for deployment" >> "$GITHUB_OUTPUT"

      - name: Display validation result
        run: |
          echo "## Branch Validation Result" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.validate.outputs.valid }}" = "true" ]; then
            echo "‚úÖ **PASSED**: ${{ steps.validate.outputs.message }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **FAILED**: ${{ steps.validate.outputs.message }}" >> $GITHUB_STEP_SUMMARY
          fi

  wait-for-queue:
    name: Wait for Deployment Queue
    needs: validate-branch
    if: needs.validate-branch.outputs.branch_valid == 'true' && (github.event.inputs.action == 'deploy' || github.event_name == 'push')
    runs-on: ubuntu-latest
    outputs:
      position: ${{ steps.check-queue.outputs.position }}
    steps:
      - name: Check queue position and wait
        id: check-queue
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          CURRENT_RUN_ID=${{ github.run_id }}
          WAIT_PER_JOB=120  # 2 minutes per earlier job

          echo "üîç Current run ID: $CURRENT_RUN_ID"
          echo "‚è±Ô∏è  Checking for earlier deployments..."

          # Count earlier in-progress or queued runs
          EARLIER_RUNS=$(gh run list \
            --repo ${{ github.repository }} \
            --workflow deploy-hetzner.yml \
            --limit 100 \
            --json databaseId,status,headBranch,createdAt \
            | jq --arg current "$CURRENT_RUN_ID" \
            '[.[] | select((.status == "in_progress" or .status == "queued") and .databaseId < ($current | tonumber))] | length')

          echo "position=$((EARLIER_RUNS + 1))" >> $GITHUB_OUTPUT

          if [ "$EARLIER_RUNS" -eq 0 ]; then
            echo "‚úÖ No earlier deployments found. Starting immediately!"
            echo "üìä Queue position: 1 of 1"
            exit 0
          fi

          # Calculate wait time
          TOTAL_WAIT=$((EARLIER_RUNS * WAIT_PER_JOB))
          TOTAL_WAIT_MIN=$((TOTAL_WAIT / 60))

          echo "üìä Queue position: $((EARLIER_RUNS + 1))"
          echo "üöÄ Found $EARLIER_RUNS earlier deployment(s)"
          echo "‚è≥ Waiting $TOTAL_WAIT seconds ($TOTAL_WAIT_MIN minutes total)"
          echo ""
          echo "Earlier deployments in queue:"

          # Show details of earlier runs
          gh run list \
            --repo ${{ github.repository }} \
            --workflow deploy-hetzner.yml \
            --limit 100 \
            --json databaseId,status,headBranch,createdAt \
            | jq --arg current "$CURRENT_RUN_ID" \
            '.[] | select((.status == "in_progress" or .status == "queued") and .databaseId < ($current | tonumber)) |
            "  - Run #\(.databaseId) - Branch: \(.headBranch) - Status: \(.status) - Started: \(.createdAt)"' -r

          echo ""
          echo "‚è∞ Estimated start time: $(date -d "+$TOTAL_WAIT seconds")"

          # Wait with progress updates
          ELAPSED=0
          while [ $ELAPSED -lt $TOTAL_WAIT ]; do
            REMAINING=$((TOTAL_WAIT - ELAPSED))
            REMAINING_MIN=$((REMAINING / 60))
            REMAINING_SEC=$((REMAINING % 60))

            echo "‚è≥ Time remaining: ${REMAINING_MIN}m ${REMAINING_SEC}s"

            # Check every 30 seconds if earlier jobs finished early
            sleep 30
            ELAPSED=$((ELAPSED + 30))

            # Re-check if deployments finished early
            STILL_RUNNING=$(gh run list \
              --repo ${{ github.repository }} \
              --workflow deploy-hetzner.yml \
              --limit 100 \
              --json databaseId,status \
              | jq --arg current "$CURRENT_RUN_ID" \
              '[.[] | select((.status == "in_progress" or .status == "queued") and .databaseId < ($current | tonumber))] | length')

            if [ "$STILL_RUNNING" -eq 0 ]; then
              echo "‚úÖ All earlier deployments completed early!"
              echo "üöÄ Starting deployment now (saved $((REMAINING / 60)) minutes)"
              exit 0
            fi
          done

          echo "‚úÖ Wait time completed. Proceeding with deployment!"

  deploy:
    name: Deploy to Hetzner (Position ${{ needs.wait-for-queue.outputs.position }})
    needs: [validate-branch, wait-for-queue]
    if: needs.validate-branch.outputs.branch_valid == 'true' && (github.event.inputs.action == 'deploy' || github.event_name == 'push')
    runs-on: ubuntu-latest
    environment:
      name: nr-experiments
      url: ${{ steps.branch-name.outputs.deployment_url }}
    steps:
      - name: Sanitize branch name for URL
        id: branch-name
        run: |
          # Get the branch name
          BRANCH="${{ github.event.inputs.branch || github.ref_name }}"
          # Use the SAME sanitization as deploy.sh (line 671)
          # Replace all non-alphanumeric characters with hyphens and convert to lowercase
          SANITIZED_BRANCH=$(echo "$BRANCH" | sed 's/[^a-zA-Z0-9]/-/g' | tr '[:upper:]' '[:lower:]')
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
          echo "sanitized=$SANITIZED_BRANCH" >> $GITHUB_OUTPUT
          echo "deployment_url=https://nr-${SANITIZED_BRANCH}.${{ vars.TAILNET }}.ts.net" >> $GITHUB_OUTPUT
          echo "üìã Branch: $BRANCH"
          echo "üîó Sanitized: $SANITIZED_BRANCH"
          echo "üåê URL: https://nr-${SANITIZED_BRANCH}.${{ vars.TAILNET }}.ts.net"

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup SSH key
        shell: bash
        env:
          SSH_KEY: ${{ secrets.HETZNER_SSH_KEY }}
          SSH_HOST: ${{ secrets.HETZNER_HOST }}
        run: |
          # Create SSH directory with proper permissions
          install -m 700 -d ~/.ssh

          # Install SSH private key
          echo "$SSH_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

          # Add host key to known_hosts for security
          ssh-keyscan -H "$SSH_HOST" >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts

      - name: Deploy to Hetzner
        shell: bash
        env:
          DEPLOY_MODE: remote
          HETZNER_HOST: ${{ secrets.HETZNER_HOST }}
          HETZNER_USER: ${{ secrets.HETZNER_USER }}
          HETZNER_SSH_KEY: ~/.ssh/id_rsa
          TS_AUTHKEY: ${{ secrets.TS_AUTHKEY }}
          TAILNET: ${{ vars.TAILNET }}
          TALLY_TOKEN: ${{ secrets.TALLY_TOKEN }}
          GITHUB_REPO: ${{ env.GITHUB_REPO }}
          GITHUB_ISSUES_REPO: ${{ env.GITHUB_ISSUES_REPO }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BRANCH_NAME: ${{ github.event.inputs.branch || github.ref_name }}
        run: |
          set -euo pipefail

          echo "::group::üöÄ Starting deployment to Hetzner"
          echo "üìã Branch: $BRANCH_NAME"
          echo "üñ•Ô∏è  Server: $HETZNER_HOST"
          echo "üîó Tailnet: $TAILNET"
          echo "::endgroup::"

          # Execute deployment with error handling
          if bash deploy.sh up; then
            echo "::notice::Deployment completed successfully"
          else
            echo "::error::Deployment failed"
            exit 1
          fi

          # Write results to job summary
          {
            echo "## üéØ Deployment Results"
            echo ""
            echo "‚úÖ **SUCCESS**: Branch \`$BRANCH_NAME\` deployed to Hetzner"
            echo ""
            echo "### üîó Access URLs"
            echo "- **Node-RED**: https://nr-$BRANCH_NAME.$TAILNET.ts.net"
            echo "- **Dashboard**: https://dashboard.$TAILNET.ts.net"
            echo ""
            echo "### üìã Details"
            echo "- **Server**: \`$HETZNER_HOST\`"
            echo "- **Branch**: \`$BRANCH_NAME\`"
            echo "- **Timestamp**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Cleanup SSH key
        if: always()
        shell: bash
        run: |
          # Securely remove SSH private key
          if [ -f ~/.ssh/id_rsa ]; then
            shred -u ~/.ssh/id_rsa 2>/dev/null || rm -f ~/.ssh/id_rsa
          fi

  cleanup:
    name: Cleanup Hetzner Deployment
    needs: validate-branch
    if: github.event.inputs.action == 'cleanup' || github.event.inputs.action == 'cleanup-with-dashboard'
    runs-on: ubuntu-latest
    environment: nr-experiments
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup SSH key
        shell: bash
        env:
          SSH_KEY: ${{ secrets.HETZNER_SSH_KEY }}
          SSH_HOST: ${{ secrets.HETZNER_HOST }}
        run: |
          # Create SSH directory with proper permissions
          install -m 700 -d ~/.ssh

          # Install SSH private key
          echo "$SSH_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

          # Add host key to known_hosts for security
          ssh-keyscan -H "$SSH_HOST" >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts

      - name: Cleanup Hetzner deployment
        shell: bash
        env:
          DEPLOY_MODE: remote
          HETZNER_HOST: ${{ secrets.HETZNER_HOST }}
          HETZNER_USER: ${{ secrets.HETZNER_USER }}
          HETZNER_SSH_KEY: ~/.ssh/id_rsa
          TS_AUTHKEY: ${{ secrets.TS_AUTHKEY }}
          TAILNET: ${{ vars.TAILNET }}
          TALLY_TOKEN: ${{ secrets.TALLY_TOKEN }}
          GITHUB_REPO: ${{ env.GITHUB_REPO }}
          GITHUB_ISSUES_REPO: ${{ env.GITHUB_ISSUES_REPO }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BRANCH_NAME: ${{ github.event.inputs.branch || github.ref_name }}
          ACTION: ${{ github.event.inputs.action }}
        run: |
          set -euo pipefail

          # Determine if we should remove dashboard based on action
          REMOVE_DASHBOARD="false"
          if [ "$ACTION" = "cleanup-with-dashboard" ]; then
            REMOVE_DASHBOARD="true"
          fi

          echo "::group::üßπ Starting cleanup of Hetzner deployment"
          echo "üìã Branch: $BRANCH_NAME"
          echo "üóëÔ∏è  Remove Dashboard: $REMOVE_DASHBOARD"
          echo "üñ•Ô∏è  Server: $HETZNER_HOST"
          echo "::endgroup::"

          # Execute cleanup with optional dashboard removal
          if [ "$REMOVE_DASHBOARD" = "true" ]; then
            if bash deploy.sh down --remove-dashboard; then
              echo "::notice::Cleanup with dashboard removal completed successfully"
            else
              echo "::error::Cleanup failed"
              exit 1
            fi
          else
            if bash deploy.sh down; then
              echo "::notice::Cleanup completed successfully"
            else
              echo "::error::Cleanup failed"
              exit 1
            fi
          fi

          # Write results to job summary
          dashboard_status=$([ "$REMOVE_DASHBOARD" = "true" ] && echo "Completely removed" || echo "Updated and preserved")
          {
            echo "## üßπ Cleanup Results"
            echo ""
            echo "‚úÖ **SUCCESS**: Branch \`$BRANCH_NAME\` cleanup completed"
            echo ""
            echo "### üìã Details"
            echo "- **Server**: \`$HETZNER_HOST\`"
            echo "- **Branch**: \`$BRANCH_NAME\`"
            echo "- **Dashboard**: $dashboard_status"
            echo "- **Timestamp**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Cleanup SSH key
        if: always()
        shell: bash
        run: |
          # Securely remove SSH private key
          if [ -f ~/.ssh/id_rsa ]; then
            shred -u ~/.ssh/id_rsa 2>/dev/null || rm -f ~/.ssh/id_rsa
          fi

  auto-rebase:
    name: Automatic Rebase
    needs: validate-branch
    if: needs.validate-branch.outputs.needs_rebase == 'true' && (github.event.inputs.action == 'deploy' || github.event_name == 'push')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ github.token }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Perform automatic rebase and trigger deployment
        env:
          BRANCH_NAME: ${{ github.event.inputs.branch || github.ref_name }}
          BASE_BRANCH: experiment-template
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          echo "::group::üîÑ Performing automatic rebase"
          echo "üìã Branch: $BRANCH_NAME"
          echo "üìç Base: $BASE_BRANCH"

          # Fetch latest changes
          git fetch --all --prune

          # Checkout the branch
          git checkout "$BRANCH_NAME"

          # Attempt rebase
          if git rebase "origin/$BASE_BRANCH"; then
            echo "‚úÖ Rebase successful - no conflicts"
            
            # Push the rebased branch using the default GITHUB_TOKEN
            echo "::notice::Pushing rebased branch..."
            git push --force-with-lease origin "$BRANCH_NAME"
            echo "::notice::‚úÖ Branch rebased and pushed successfully"
            
            # Wait a moment for the push to be processed
            sleep 3
            
            # Now trigger the deployment workflow using workflow_dispatch
            echo "::notice::Triggering deployment workflow..."
            
            # Use gh CLI to trigger the workflow (this bypasses the GITHUB_TOKEN push limitation)
            if gh workflow run deploy-hetzner.yml \
              --ref "$BRANCH_NAME" \
              -f branch="$BRANCH_NAME" \
              -f action=deploy; then
              
              echo "::notice::‚úÖ Deployment workflow triggered for rebased branch"
              echo ""
              echo "üìã Branch: $BRANCH_NAME"
              echo "üöÄ Action: deploy"
              echo ""
              echo "Check the Actions tab for the new workflow run:"
              echo "https://github.com/${{ github.repository }}/actions/workflows/deploy-hetzner.yml"
            else
              echo "::warning::Failed to trigger deployment workflow automatically"
              echo "::notice::Branch was rebased successfully, but you'll need to manually trigger deployment"
              echo "::notice::Go to: https://github.com/${{ github.repository }}/actions/workflows/deploy-hetzner.yml"
            fi
          else
            echo "::error::‚ùå Rebase failed due to conflicts"
            echo "::notice::Manual intervention required. Run these commands locally:"
            echo ""
            echo "git fetch origin"
            echo "git checkout $BRANCH_NAME"
            echo "git rebase origin/$BASE_BRANCH"
            echo "# Resolve conflicts, then:"
            echo "git rebase --continue"
            echo "git push --force-with-lease origin $BRANCH_NAME"
            exit 1
          fi

          echo "::endgroup::"

      - name: Create job summary
        if: success()
        run: |
          {
            echo "## üîÑ Automatic Rebase Completed"
            echo ""
            echo "‚úÖ **SUCCESS**: Branch \`${{ github.event.inputs.branch || github.ref_name }}\` has been rebased on \`experiment-template\`"
            echo ""
            echo "The branch has been pushed and a new deployment workflow will start automatically."
            echo ""
            echo "**Timestamp**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          } >> "$GITHUB_STEP_SUMMARY"

  validation-failed:
    name: Branch Validation Failed
    needs: validate-branch
    if: needs.validate-branch.outputs.branch_valid != 'true' && needs.validate-branch.outputs.needs_rebase != 'true' && (github.event.inputs.action == 'deploy' || github.event_name == 'push')
    runs-on: ubuntu-latest
    steps:
      - name: Display validation failure
        shell: bash
        env:
          BRANCH_NAME: ${{ github.event.inputs.branch || github.ref_name }}
          VALIDATION_MESSAGE: ${{ needs.validate-branch.outputs.validation_message }}
        run: |
          echo "::error::Branch validation failed: $VALIDATION_MESSAGE"

          # Write detailed failure information to job summary
          {
            echo "## ‚ùå Branch Validation Failed"
            echo ""
            echo "**Branch**: \`$BRANCH_NAME\`"
            echo ""
            echo "**Reason**: $VALIDATION_MESSAGE"
            echo ""
            echo "### üîß Required Actions"
            echo ""
            echo "1. **Rebase your branch on the latest \`experiment-template\`**:"
            echo "   \`\`\`bash"
            echo "   git fetch origin"
            echo "   git checkout $BRANCH_NAME"
            echo "   git rebase origin/experiment-template"
            echo "   git push --force-with-lease origin $BRANCH_NAME"
            echo "   \`\`\`"
            echo ""
            echo "2. **Re-run this workflow** after fixing the branch"
            echo ""
            echo "### üìñ Additional Resources"
            echo "- [Git Rebase Documentation](https://git-scm.com/docs/git-rebase)"
            echo "- [Force Push Safely with --force-with-lease](https://git-scm.com/docs/git-push#Documentation/git-push.txt---force-with-leaseltrefnamegt)"
          } >> "$GITHUB_STEP_SUMMARY"

          echo "‚ùå Deployment cancelled due to branch validation failure"
          exit 1
