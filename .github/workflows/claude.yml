name: Claude Code

on:
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  issues:
    types: [opened, assigned]
  pull_request_review:
    types: [submitted]

jobs:
  claude:
    if: |
      (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'pull_request_review' && contains(github.event.review.body, '@claude')) ||
      (github.event_name == 'issues' && (contains(github.event.issue.body, '@claude') || contains(github.event.issue.title, '@claude')))
    runs-on: ubuntu-latest
    outputs:
      issue-id: ${{ steps.detect-branch.outputs.issue_id }}
    permissions:
      contents: read
      pull-requests: read
      issues: read
      id-token: write
      actions: read # Required for Claude to read CI results on PRs
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          sparse-checkout: |
            .gitattributes
            .github/
            .gitignore
            .jshintrc
            API.md
            CHANGELOG.md
            CITATION.cff
            CODE_OF_CONDUCT.md
            CONTRIBUTING.md
            Gruntfile.js
            jsdoc.json
            LICENSE
            nodemon.json
            package.json
            packages/
            README.md
            scripts/
            SECURITY.md
            test/
          sparse-checkout-cone-mode: false

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"

      - name: Install dependencies
        run: npm install

      - name: Install Playwright browsers and dependencies
        run: npx playwright install --with-deps chromium

      - name: Build Node-RED
        run: npm run build

      - name: Start Node-RED in background
        run: |
          npm start &
          echo $! > node-red.pid
          # Wait for Node-RED to start
          sleep 10
          curl -f http://localhost:1880 || (echo "Node-RED failed to start" && exit 1)

      - name: Ensure Playwright MCP directory exists
        run: mkdir -p .playwright-mcp

      # Create a persistent plan file for state sharing between steps
      - name: Initialize plan file
        run: echo "# Implementation Plan" > plan.md

      # Step 1: Analysis only - explicitly prevent changes
      - name: Step 1 - Analyze Request and Plan
        id: analyze-and-plan
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          claude_args: |
            --system-prompt "You are an expert Node-RED developer with strong UI/UX design knowledge.
            ## CRITICAL INSTRUCTION: ANALYSIS ONLY - NO CHANGES
            Your ONLY task is to understand the request and create a detailed plan. You MUST NOT make any code changes, file modifications, or implementations in this step.
            ## Step 1: Understand and Create Plan
            1. Read the GitHub issue/comment that triggered this workflow
            2. Explore the Node-RED codebase to understand current implementation
            3. Create a specific implementation plan and SAVE IT TO plan.md:
               - Which specific UI areas/components will be affected
               - What files need to be modified  
               - What the expected visual changes will be (numbered list)
               - Step-by-step implementation approach
               - UX considerations: visual hierarchy, color consistency, sufficient contrast, intuitive interactions, accessibility, touch-friendly sizing. Adherence to existing design patterns takes priority unless requested differently. Do not extend scope unnecessarily.
            4. Navigate to and take comprehensive initial screenshots of ALL areas that will be modified using playwright:
               - Identify all distinct UI areas/components that will be affected by the requested changes
               - For EACH identified area, capture screenshots using this numbering system:
                 * Area 1: Main editor/workspace - before-1-[resolution].png  
                 * Area 2: Node palette - before-2-[resolution].png
                 * Area 3: Sidebar - before-3-[resolution].png
                 * Continue numbering for additional areas (before-4-, before-5-, etc.)
               - Use mcp__playwright__browser_resize to set each resolution before capturing
               - Capture 4 resolutions for EACH area with these exact filenames:
                 * Desktop (1920x1080) â†’ before-1-desktop.png, before-2-desktop.png, etc.
                 * Laptop (1440x900) â†’ before-1-laptop.png, before-2-laptop.png, etc.
                 * Tablet (768x1024) â†’ before-1-tablet.png, before-2-tablet.png, etc.
                 * Mobile (375x667) â†’ before-1-mobile.png, before-2-mobile.png, etc.
               - Navigate to different UI states/views if needed to capture all relevant areas
            ## Environment
            Node-RED is running on http://localhost:1880
            SAVE YOUR COMPLETE PLAN TO plan.md - this will be read by subsequent steps.
            REMINDER: Do NOT implement anything - only analyze and plan."
            --mcp-config '{"mcpServers":{"playwright":{"command":"npx","args":["@playwright/mcp@latest","--headless"]}}}' 
            --allowedTools mcp__playwright__browser_navigate,mcp__playwright__browser_snapshot,mcp__playwright__browser_take_screenshot,mcp__playwright__browser_resize,mcp__playwright__browser_wait_for,mcp__playwright__browser_click,mcp__playwright__browser_evaluate,Write,Read

      # Ensure Node-RED is running before Step 2
      - name: Verify Node-RED Status Before Step 2
        run: |
          if ! curl -f http://localhost:1880 >/dev/null 2>&1; then
            echo "Node-RED not responding, rebuilding and restarting..."
            npm run build
            npm start &
            echo $! > node-red.pid
            sleep 15
            curl -f http://localhost:1880 || (echo "Node-RED failed to start" && exit 1)
          else
            echo "Node-RED is running properly"
          fi

      # Step 2: Implementation based on saved plan
      - name: Step 2 - Implement and Test Changes
        id: implement-changes
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          claude_args: |
            --system-prompt "You are an expert Node-RED developer with strong UI/UX design knowledge.
            ## CRITICAL INSTRUCTION: IMPLEMENT CHANGES THROUGH ITERATIVELY TESTING CHANGES AND REFINING BASED ON PLAYWRIGHT FEEDBACK
            You are continuing the work from Step 1 by implementing changes for GitHub issue #${{ github.event.issue.number || github.event.pull_request.number }}
            ## Context from Step 1:
            - Implementation plan is saved in plan.md - READ THIS FIRST
            - Node-RED server should be running on http://localhost:1880 (verify with curl) otherwise restart it
            ## Step 2: Implement and iteratively adjust based on Playwright testing until completion of plan
            You are working on the implementation phase with iterative testing and refinement. Follow this process:
            ### MANDATORY Implementation Loop Process
            1. READ the detailed plan from plan.md - this contains the complete implementation strategy created in Step 1
            2. Make SMALL incremental changes (not the entire implementation at once)
            3. For frontend changes: run npm run build to rebuild assets
            4. For backend/core changes: restart Node-RED if needed using:
               kill $(cat node-red.pid) && npm start & && echo $! > node-red.pid && sleep 10
            5. **MANDATORY: Navigate to http://localhost:1880 and test with Playwright**
            6. **MANDATORY: Take screenshot and analyze what you see vs what was expected**
            7. **If testing reveals issues: make additional changes and repeat from step 3**
            8. **Repeat steps 2-7 until each small change is verified working**
            9. **ONLY consider complete when Playwright confirms all functionality works correctly**
            ## CRITICAL: You MUST test each change with Playwright before proceeding
            - Do NOT implement multiple features without testing each one
            - Do NOT assume your code works - verify with browser automation
            - Use Playwright to see the actual visual result after every change
            ## Playwright-Driven Iterative Development
            - ALWAYS use Playwright for all browser testing and feedback
            - Use Playwright to discover what needs adjustment: UI layout, functionality, user experience
            - Let Playwright testing guide your implementation decisions
            - After each code change, immediately test with Playwright browser automation
            - Use Playwright findings to refine and improve the implementation
            - Continue the implement â†’ test â†’ refine cycle until Playwright confirms success
            ## ABSOLUTE REQUIREMENT: Let Playwright Drive Improvements
            - NEVER implement code without immediately testing it with Playwright
            - Don't just implement the plan - let Playwright testing show you what actually works
            - Use browser automation to discover edge cases and usability issues
            - Make iterative improvements based on what you observe through Playwright
            - The plan is your starting point, but Playwright testing should guide refinements
            - If you complete Step 2 without using Playwright extensively, you have FAILED
            ## Implementation Guidelines
            - Apply UI/UX best practices based on what Playwright testing reveals: visual hierarchy, color consistency, sufficient contrast, intuitive interactions, accessibility, touch-friendly sizing. Adherence to existing design patterns takes priority unless requested differently. Do not extend scope unnecessarily.
            - Maintain consistency with existing interface patterns  
            - Focus on what the plan specifies, but improve based on testing feedback
            - Don't stop at good enough - iterate until Playwright confirms functional and visual excellence
            ## Environment
            - Node-RED is running on http://localhost:1880
            - You are working on branch: ${{ env.CLAUDE_BRANCH }}
            - The plan file contains your starting strategy - use it with Playwright feedback
            Begin iterative implementation now."
            --mcp-config '{"mcpServers":{"playwright":{"command":"npx","args":["@playwright/mcp@latest","--headless"]}}}' 
            --allowedTools mcp__playwright__browser_close,mcp__playwright__browser_resize,mcp__playwright__browser_console_messages,mcp__playwright__browser_handle_dialog,mcp__playwright__browser_evaluate,mcp__playwright__browser_file_upload,mcp__playwright__browser_fill_form,mcp__playwright__browser_install,mcp__playwright__browser_press_key,mcp__playwright__browser_type,mcp__playwright__browser_navigate,mcp__playwright__browser_navigate_back,mcp__playwright__browser_network_requests,mcp__playwright__browser_take_screenshot,mcp__playwright__browser_snapshot,mcp__playwright__browser_click,mcp__playwright__browser_drag,mcp__playwright__browser_hover,mcp__playwright__browser_select_option,mcp__playwright__browser_tabs,mcp__playwright__browser_wait_for,Read,Write,Edit,MultiEdit,Bash

      # Ensure Node-RED is running before Step 3
      - name: Verify Node-RED Status Before Step 3
        run: |
          if ! curl -f http://localhost:1880 >/dev/null 2>&1; then
            echo "Node-RED not responding, rebuilding and restarting..."
            npm run build
            npm start &
            echo $! > node-red.pid
            sleep 15
            curl -f http://localhost:1880 || (echo "Node-RED failed to start" && exit 1)
          else
            echo "Node-RED is running properly"
          fi

      - name: Extract Issue Information and Detect Branch
        id: detect-branch
        run: |
          BRANCH=$(git branch --show-current)
          echo "Step 1 created/used branch: $BRANCH"
          echo "branch_name=$BRANCH" >> $GITHUB_OUTPUT
          echo "CLAUDE_BRANCH=$BRANCH" >> $GITHUB_ENV

          # Extract issue/PR number for folder structure
          ISSUE_NUMBER="${{ github.event.issue.number || github.event.pull_request.number }}"
          echo "ISSUE_ID=$ISSUE_NUMBER" >> $GITHUB_ENV
          echo "issue_id=$ISSUE_NUMBER" >> $GITHUB_OUTPUT
          echo "Issue/PR Number: $ISSUE_NUMBER"

      # Step 3: Screenshot documentation
      - name: Step 3 - Take After Screenshots
        id: post-comparison
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          claude_args: |
            --system-prompt "You are a screenshot automation tool.
            ## CRITICAL INSTRUCTION: SCREENSHOTS ONLY - NO CODE MODIFICATIONS
            You are in the FINAL SCREENSHOT phase. Your ONLY permitted actions are:
            - READ plan.md ONLY to find which UI areas need screenshots (do NOT implement the plan)
            - TAKE SCREENSHOTS using Playwright
            - WRITE screenshot files (after-[number]-[resolution].png) only
            YOU MUST NOT:
            - Modify any source code files (.js, .html, .css, .json, etc.)
            - Make additional implementations or improvements
            - Change Node-RED functionality in any way
            - Edit existing implementation files
            ## Step 3: Take After Screenshots for GitHub issue #${{ github.event.issue.number || github.event.pull_request.number }}
            You are taking final screenshots on branch: ${{ env.CLAUDE_BRANCH }}
            ## Your Screenshot Tasks:
            1. FIND existing before-[number]-[resolution].png screenshots that Step 1 created (with resolution suffixes) in .playwright-mcp/ directory
            2. For each before-[number]-[resolution].png found, take a matching after-[number]-[resolution].png screenshot
            3. Navigate to http://localhost:1880 and capture the same areas at the same resolutions
            ## Multi-Resolution Screenshot Requirements:
            - Use mcp__playwright__browser_resize to match the resolution used in Step 1
            - Capture all 4 resolutions with these exact filenames:
              * Desktop (1920x1080) â†’ after-1-desktop.png, after-2-desktop.png, etc.
              * Laptop (1440x900) â†’ after-1-laptop.png, after-2-laptop.png, etc.
              * Tablet (768x1024) â†’ after-1-tablet.png, after-2-tablet.png, etc.
              * Mobile (375x667) â†’ after-1-mobile.png, after-2-mobile.png, etc.
            ## Playwright Usage
            - Take after-[number]-[resolution].png screenshots using Playwright's screenshot capability
            - Save screenshots to .playwright-mcp/ directory
            ## Environment
            - Node-RED is running on http://localhost:1880
            - You are working on branch: ${{ env.CLAUDE_BRANCH }}
            ## REMINDER: SCREENSHOTS ONLY
            Your ONLY task is to take after-[number]-[resolution].png screenshots that match the before-[number]-[resolution].png screenshots from Step 1. Do NOT create reports or modify any code files.
            Begin taking screenshots now."
            --mcp-config '{"mcpServers":{"playwright":{"command":"npx","args":["@playwright/mcp@latest","--headless"]}}}'
            --allowedTools mcp__playwright__browser_navigate,mcp__playwright__browser_snapshot,mcp__playwright__browser_take_screenshot,mcp__playwright__browser_resize,mcp__playwright__browser_wait_for,mcp__playwright__browser_click,mcp__playwright__browser_evaluate,Write,Read

      # Archive screenshots with issue and commit hash
      - name: Archive Screenshots to Issue/Commit Folder
        if: always() && steps.post-comparison.conclusion != 'skipped'
        run: |
          # Get the last commit hash
          COMMIT_HASH=$(git rev-parse HEAD)
          SCREENSHOT_DIR="${{ env.ISSUE_ID }}/${COMMIT_HASH}"

          # Create directory with issue/commit structure
          mkdir -p "$SCREENSHOT_DIR"

          # Copy only before-*.png and after-*.png screenshots to commit folder
          if [ -d ".playwright-mcp" ]; then
            # Use bash arrays to safely handle files that may or may not exist
            shopt -s nullglob  # Make glob patterns expand to nothing if no matches
            for file in .playwright-mcp/before-*.png; do
              [ -f "$file" ] && cp "$file" "$SCREENSHOT_DIR/"
            done
            for file in .playwright-mcp/after-*.png; do
              [ -f "$file" ] && cp "$file" "$SCREENSHOT_DIR/"
            done
            shopt -u nullglob  # Reset nullglob
          fi

          # Create metadata file for GitHub Pages workflow
          cat > "$SCREENSHOT_DIR/metadata.json" << EOF
          {
            "issue_number": "${{ env.ISSUE_ID }}",
            "commit_hash": "$COMMIT_HASH",
            "repository_owner": "${{ github.repository_owner }}",
            "repository_name": "${{ github.event.repository.name }}",
            "event_type": "${{ github.event_name }}",
            "created_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          }
          EOF

      # Upload screenshots as artifact for deployment job
      - name: Upload Screenshots Artifact
        if: always() && steps.post-comparison.conclusion != 'skipped'
        uses: actions/upload-artifact@v4
        with:
          name: screenshots-${{ env.ISSUE_ID }}-${{ github.run_id }}
          path: ${{ env.ISSUE_ID }}/
          retention-days: 1

  # Separate job to deploy screenshots to gh-pages with write permissions
  deploy-screenshots:
    needs: claude
    runs-on: ubuntu-latest
    if: needs.claude.result == 'success'
    permissions:
      contents: write # Required to push to gh-pages branch
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download Screenshots Artifact
        uses: actions/download-artifact@v4
        with:
          name: screenshots-${{ needs.claude.outputs.issue-id }}-${{ github.run_id }}
          path: ./screenshots

      - name: Deploy Screenshots to gh-pages
        run: |
          # Set up git config for commits
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"

          # Create a worktree for gh-pages branch
          git fetch origin gh-pages:gh-pages || git checkout --orphan gh-pages
          git worktree add ../gh-pages-deploy gh-pages || {
            # If worktree already exists, remove and recreate
            git worktree remove ../gh-pages-deploy --force 2>/dev/null || true
            git worktree add ../gh-pages-deploy gh-pages
          }

          # Copy all screenshot directories to the worktree
          if [ -d "./screenshots" ]; then
            cp -r ./screenshots/. "../gh-pages-deploy/" 2>/dev/null || true
          fi

          # Switch to worktree and commit
          cd ../gh-pages-deploy

          # Check if there are any changes to commit
          if [ -n "$(git status --porcelain)" ]; then
            git add .
            git commit -m "Add screenshots from workflow run ${{ github.run_id }}

            Event: ${{ github.event_name }}
            Repository: ${{ github.repository }}
            Run ID: ${{ github.run_id }}"

            git push origin gh-pages
            echo "Screenshots deployed to gh-pages"
          else
            echo "No screenshots to deploy"
          fi

  # Deploy to GitHub Pages after screenshot deployment
  deploy-to-pages:
    needs: deploy-screenshots
    runs-on: ubuntu-latest
    if: needs.deploy-screenshots.result == 'success'
    permissions:
      contents: read
      pages: write
      id-token: write
      pull-requests: write # Write for PR comments
      issues: write # Write for issue comments
    concurrency:
      group: "pages"
      cancel-in-progress: false
    steps:
      - name: Checkout gh-pages branch
        uses: actions/checkout@v4
        with:
          ref: gh-pages

      - name: Setup Pages
        uses: actions/configure-pages@v5

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: "."
          # The action automatically excludes .git and other hidden directories

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

  # Post screenshot comparisons after successful deployment
  post-comparison:
    needs: deploy-to-pages
    runs-on: ubuntu-latest
    if: success()
    steps:
      - name: Checkout gh-pages branch
        uses: actions/checkout@v4
        with:
          ref: gh-pages

      - name: Find new screenshot directories and post comparisons
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const { promisify } = require('util');
            const readdir = promisify(fs.readdir);
            const readFile = promisify(fs.readFile);
            const writeFile = promisify(fs.writeFile);
            const stat = promisify(fs.stat);
            
            // Find all metadata.json files in ISSUE_ID/COMMIT_HASH/ structure
            async function findMetadataFiles() {
              const metadataFiles = [];
              
              try {
                const items = await readdir('.');
                
                for (const item of items) {
                  try {
                    const itemStat = await stat(item);
                    if (itemStat.isDirectory() && /^\d+$/.test(item)) { // Check if directory name is numeric (issue ID)
                      const issueDir = item;
                      const issueDirItems = await readdir(issueDir);
                      
                      for (const subItem of issueDirItems) {
                        const subPath = path.join(issueDir, subItem);
                        const subStat = await stat(subPath);
                        
                        if (subStat.isDirectory()) { // This should be the commit hash directory
                          const metadataPath = path.join(subPath, 'metadata.json');
                          try {
                            await stat(metadataPath);
                            metadataFiles.push(metadataPath);
                          } catch (err) {
                            // metadata.json doesn't exist in this directory, skip
                          }
                        }
                      }
                    }
                  } catch (err) {
                    console.log(`Skipping item ${item}: ${err.message}`);
                  }
                }
              } catch (err) {
                console.log(`Error reading directory: ${err.message}`);
              }
              
              return metadataFiles;
            }
            
            // Process each metadata file
            const metadataFiles = await findMetadataFiles();
            console.log(`Found ${metadataFiles.length} metadata files to process`);
            
            for (const metadataPath of metadataFiles) {
              console.log(`Processing: ${metadataPath}`);
              
              try {
                // Read and parse metadata
                const metadataContent = await readFile(metadataPath, 'utf8');
                const metadata = JSON.parse(metadataContent);
                
                // Validate essential data
                if (!metadata.issue_number || !metadata.commit_hash) {
                  console.log(`Skipping ${metadataPath} - missing essential data`);
                  continue;
                }
                
                const issueNumber = parseInt(metadata.issue_number);
                const commitHash = metadata.commit_hash;
                const repoOwner = metadata.repository_owner;
                const repoName = metadata.repository_name;
                
                // Build image base URL
                const imageBaseUrl = `https://${repoOwner}.github.io/${repoName}/${issueNumber}/${commitHash}`;
                
                // Check for before/after screenshot pairs with resolution suffixes
                const screenshotDir = path.dirname(metadataPath);
                let commentBody = '## ðŸ“¸ Visual Comparison\n\n';
                let screenshotsFound = false;
                
                // Define resolution mapping and display names
                const resolutions = [
                  { suffix: 'desktop', name: 'Desktop (1920x1080)' },
                  { suffix: 'laptop', name: 'Laptop (1440x900)' },
                  { suffix: 'tablet', name: 'Tablet (768x1024)' },
                  { suffix: 'mobile', name: 'Mobile (375x667)' }
                ];
                
                // Look for screenshot pairs across different numbering and resolution patterns
                for (let i = 1; i <= 5; i++) {
                  let sectionFound = false;
                  let sectionBody = '';
                  
                  // Check each resolution for this screenshot number
                  for (const resolution of resolutions) {
                    const beforeFile = path.join(screenshotDir, `before-${i}-${resolution.suffix}.png`);
                    const afterFile = path.join(screenshotDir, `after-${i}-${resolution.suffix}.png`);
                    
                    try {
                      await stat(beforeFile);
                      await stat(afterFile);
                      
                      if (!sectionFound) {
                        sectionBody += `### Screenshot ${i}\n\n| Resolution | Before | After |\n|------------|--------|-------|\n`;
                        sectionFound = true;
                      }
                      
                      sectionBody += `| ${resolution.name} | ![Before ${i} ${resolution.suffix}](${imageBaseUrl}/before-${i}-${resolution.suffix}.png) | ![After ${i} ${resolution.suffix}](${imageBaseUrl}/after-${i}-${resolution.suffix}.png) |\n`;
                      screenshotsFound = true;
                    } catch (err) {
                      // Screenshot pair doesn't exist for this resolution, skip
                    }
                  }
                  
                  if (sectionFound) {
                    commentBody += sectionBody + '\n';
                  }
                }
                
                // Post comment if screenshots were found
                if (screenshotsFound) {
                  console.log(`Posting comparison for issue #${issueNumber}`);
                  
                  await github.rest.issues.createComment({
                    issue_number: issueNumber,
                    owner: repoOwner,
                    repo: repoName,
                    body: commentBody
                  });
                  
                  console.log(`Successfully posted comment for issue #${issueNumber}`);
                } else {
                  console.log(`No screenshot pairs found in ${screenshotDir}`);
                }
                
              } catch (err) {
                console.log(`Error processing ${metadataPath}: ${err.message}`);
              }
            }
